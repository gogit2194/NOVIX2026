                        appendProgressEvent({ stage: 'system', message: data.message, note: data.note }, wsChapterKey);
                    }
                }
            },
            {
                onStatus: (status) => {
                    if (wsStatusRef.current !== status) {
                        if (status === 'reconnecting') {
                            appendProgressEvent({ stage: 'connection', message: '连接中断，正在重连…' }, NO_CHAPTER_KEY);
                        }
                        if (status === 'connected' && wsStatusRef.current === 'reconnecting') {
                            appendProgressEvent({ stage: 'connection', message: '连接已恢复' }, NO_CHAPTER_KEY);
                        }
                        if (status === 'disconnected') {
                            appendProgressEvent({ stage: 'connection', message: '连接已断开' }, NO_CHAPTER_KEY);
                        }
                    }

                    wsStatusRef.current = status;
                }
            }
        );

        wsRef.current = wsController;

        // Connect to Trace WebSocket for AgentTimeline
        const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsHost = window.location.host;
        const traceWs = new WebSocket(`${wsProtocol}://${wsHost}/ws/trace`);

        traceWs.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'trace_event' && data.payload) {
                setTraceEvents(prev => [...prev.slice(-99), data.payload]); // Keep last 100 events
            }
            if (data.type === 'agent_trace_update' && data.payload) {
                setAgentTraces(prev => {
                    const existing = prev.findIndex(t => t.agent_name === data.payload.agent_name);
                    if (existing >= 0) {
                        const updated = [...prev];
                        updated[existing] = data.payload;
                        return updated;
                    }
                    return [...prev, data.payload];
                });
            }
        };

        traceWsRef.current = traceWs;

        return () => {
            if (wsController) wsController.close();
            if (traceWs) traceWs.close();
        };
    }, [projectId]);

    // Card State
    const [activeCard, setActiveCard] = useState(null);
    const [cardForm, setCardForm] = useState({
        name: '',
        description: '',
        aliases: '',
        stars: 1,
        category: '',
        rules: '',
        immutable: 'unset'
    });

    // SWR for Chapter Content
    const { data: loadedContent, mutate: mutateChapter } = useSWR(
        chapterInfo.chapter ? ['chapter', projectId, chapterInfo.chapter] : null,
        fetchChapterContent,
        {
            revalidateOnFocus: false,
            dedupingInterval: 60000, // Cache for 1 minute before checking again
            keepPreviousData: false // Don't show previous chapter data while loading (we handle this with manualContent update)
        }
    );

    const { data: volumes = [] } = useSWR(
        projectId ? ['volumes', projectId] : null,
        () => volumesAPI.list(projectId).then(res => res.data),
        { revalidateOnFocus: false }
    );

    const memoryPackChapter = agentBusy ? aiLockedChapter : chapterInfo.chapter;
    const { data: memoryPackStatus } = useSWR(
        projectId && memoryPackChapter ? ['memory-pack', projectId, memoryPackChapter] : null,
        () => memoryPackAPI.getStatus(projectId, memoryPackChapter).then(res => res.data),
        { revalidateOnFocus: false, refreshInterval: 5000 }
    );

    // Sync SWR data to manualContent
    useEffect(() => {
        if (loadedContent === undefined || state.unsavedChanges) {
            return;
        }
        if (isStreamingForActiveChapter || lockedOnActiveChapter || isDiffReviewForActiveChapter) {
            return;
        }

        const chapterKey = activeChapterKey;
        if (chapterKey === NO_CHAPTER_KEY) return;

        const lastGeneratedForChapter = Boolean(lastGeneratedByChapterRef.current?.[chapterKey]);
        if (lastGeneratedForChapter && manualContent && !(loadedContent || '').trim()) {
            return;
        }

        setManualContentByChapter((prev) => ({ ...(prev || {}), [chapterKey]: loadedContent }));
        setManualContent(loadedContent);
        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(loadedContent) });
        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });
        lastGeneratedByChapterRef.current[chapterKey] = false;
        // Only center cursor if we just switched chapters (optional optimization)
        // dispatch({ type: 'SET_CURSOR_POSITION', payload: { line: 1, column: 1 } });
    }, [
        loadedContent,
        dispatch,
        manualContent,
        state.unsavedChanges,
        activeChapterKey,
        NO_CHAPTER_KEY,
        isStreamingForActiveChapter,
        lockedOnActiveChapter,
        isDiffReviewForActiveChapter,
    ]);

    useEffect(() => {
        loadChapters();
    }, [projectId]);

    useEffect(() => {
        let active = true;
        const loadTitle = async () => {
            if (!projectId || !chapterInfo.chapter) return;
            if (chapterInfo.chapter_title && chapterInfo.chapter_title.trim()) return;
            try {
                const summaryResp = await draftsAPI.getSummary(projectId, chapterInfo.chapter);
                const summary = summaryResp.data || {};
                const title = summary.title || summary.chapter_title || '';
                if (active && title) {
                    setChapterInfo((prev) => ({ ...prev, chapter_title: title }));
                }
            } catch (e) {
                // ignore missing summary
            }
        };
        loadTitle();
        return () => {
            active = false;
        };
    }, [projectId, chapterInfo.chapter, chapterInfo.chapter_title]);

    // 监听 Context 中的 Dialog 状态
    useEffect(() => {
        if (state.createChapterDialogOpen !== showChapterDialog) {
            setShowChapterDialog(state.createChapterDialogOpen);
        }
    }, [state.createChapterDialogOpen]);

    const loadChapters = async () => {
        try {
            const resp = await draftsAPI.listChapters(projectId);
            const list = resp.data || [];
            setChapters(list);
        } catch (e) {
            logger.error('Failed to load chapters:', e);
        }
    };

    const handleChapterSelect = async (chapter, presetTitle = '') => {
        const nextChapterKey = chapter ? String(chapter) : NO_CHAPTER_KEY;
        const lockedKey = aiLockedChapterRef.current ? String(aiLockedChapterRef.current) : null;
        const preserveAgent = Boolean(lockedKey) && agentBusy;

        // 缓存当前章节内容，避免切章丢失
        if (chapterInfo.chapter) {
            const currentKey = String(chapterInfo.chapter);
            setManualContentByChapter((prev) => ({ ...(prev || {}), [currentKey]: manualContent }));
        }

        // 非写作/编辑进行中：切章时清理流式与差异态
        if (!preserveAgent) {
            stopStreaming();
            clearDiffReview();
            setStatus('editing');
        } else if (lockedKey && nextChapterKey !== lockedKey) {
            pushNotice(`正在撰写第 ${lockedKey} 章，AI 面板已锁定；已切换查看第 ${nextChapterKey} 章。`);
        }

        // Just set the chapter, let SWR handle fetching
        setChapterInfo({ chapter, chapter_title: presetTitle || '', content: '' }); // content will be filled by SWR
        setSelectionInfo({ start: 0, end: 0, text: '' });
        setAttachedSelection(null);
        setEditScope('document');

        // 优先使用本地缓存，减少切章时的“空白闪烁”
        if (nextChapterKey && nextChapterKey !== NO_CHAPTER_KEY) {
            const cached = manualContentByChapterRef.current?.[nextChapterKey];
            if (typeof cached === 'string') {
                setManualContent(cached);
                dispatch({ type: 'SET_WORD_COUNT', payload: countChars(cached) });
                dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });
            } else {
                setManualContent('');
                dispatch({ type: 'SET_WORD_COUNT', payload: 0 });
                dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });
            }
        }
        try {
            const summaryResp = await draftsAPI.getSummary(projectId, chapter);
            const summary = summaryResp.data || {};
            const normalizedChapter = summary.chapter || chapter;
            const title = summary.title || summary.chapter_title || '';
            setChapterInfo((prev) => ({
                ...prev,
                chapter: normalizedChapter,
                chapter_title: title || prev.chapter_title || ''
            }));
            if (normalizedChapter !== chapter) {
                dispatch({
                    type: 'SET_ACTIVE_DOCUMENT',
                    payload: { type: 'chapter', id: normalizedChapter, title: title || presetTitle || '' }
                });
            }
        } catch (e) {
            // Summary may not exist yet.
        }
    };

    const handleChapterCreate = async (chapterData) => {
        // Handle object from ChapterCreateDialog or direct arguments
        const chapterNum = typeof chapterData === 'object' ? chapterData.id : chapterData;
        const chapterTitle = typeof chapterData === 'object' ? chapterData.title : arguments[1];

        // Persist the new chapter immediately
        setIsSaving(true);
        let normalizedChapter = chapterNum;
        try {
            const resp = await draftsAPI.updateContent(projectId, chapterNum, {
                content: '',
                title: chapterTitle
            });
            normalizedChapter = resp.data?.chapter || chapterNum;
            addMessage('system', `已创建章节：${normalizedChapter}`, normalizedChapter);
            dispatch({
                type: 'SET_ACTIVE_DOCUMENT',
                payload: { type: 'chapter', id: normalizedChapter, title: chapterTitle || '' }
            });
        } catch (e) {
            addMessage('error', '创建章节失败: ' + e.message);
        } finally {
            setIsSaving(false);
        }

        setChapterInfo({ chapter: normalizedChapter, chapter_title: chapterTitle, content: '' });
        setManualContent('');
        stopStreaming();
        clearDiffReview();
        setShowChapterDialog(false);
        setStatus('idle');
        await loadChapters();
    };

    const addMessage = useCallback((type, content, chapterOverride = null) => {
        const key = chapterOverride ? String(chapterOverride) : activeChapterKey;
        if (!key || key === NO_CHAPTER_KEY) {
            return;
        }
        setMessagesByChapter((prev) => {
            const next = { ...(prev || {}) };
            const existing = Array.isArray(next[key]) ? next[key] : [];
            next[key] = [...existing, { type, content, time: new Date() }].slice(-200);
            return next;
        });
    }, [activeChapterKey, NO_CHAPTER_KEY]);

    const appendProgressEvent = useCallback((partial, chapterOverride = null) => {
        const key = chapterOverride ? String(chapterOverride) : activeChapterKey;
        if (!key || key === NO_CHAPTER_KEY) {
            return;
        }
        const event = {
            id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
            timestamp: Date.now(),
            ...partial
        };
        setProgressEventsByChapter((prev) => {
            const next = { ...(prev || {}) };
            const existing = Array.isArray(next[key]) ? next[key] : [];
            next[key] = [...existing.slice(-199), event];
            return next;
        });
    }, [activeChapterKey, NO_CHAPTER_KEY]);

    // Auto Save（类似 VSCode：检测到变更后自动保存）
    const autosaveTimerRef = useRef(null);
    const autosaveInFlightRef = useRef(false);
    const autosaveLastPayloadRef = useRef({ chapter: null, content: null, title: null });

    useEffect(() => {
        if (!state.unsavedChanges) return;
        if (!projectId || !chapterInfo.chapter) return;
        if (isStreamingForActiveChapter || lockedOnActiveChapter || isDiffReviewForActiveChapter) return;

        const nextContent = String(manualContent || '');
        const nextTitle = String(chapterInfo.chapter_title || '').trim() || null;

        const last = autosaveLastPayloadRef.current || {};
        const sameChapter = String(last.chapter || '') === String(chapterInfo.chapter);
        const sameContent = sameChapter && String(last.content || '') === nextContent;
        const sameTitle = sameChapter && (last.title || null) === nextTitle;
        if (sameContent && sameTitle) return;

        if (autosaveTimerRef.current) {
            window.clearTimeout(autosaveTimerRef.current);
        }

        autosaveTimerRef.current = window.setTimeout(async () => {
            if (autosaveInFlightRef.current) return;
            autosaveInFlightRef.current = true;
            try {
                const payload = { content: nextContent };
                if (nextTitle) payload.title = nextTitle;

                const resp = await draftsAPI.autosaveContent(projectId, chapterInfo.chapter, payload);
                if (resp.data?.success) {
                    autosaveLastPayloadRef.current = { chapter: chapterInfo.chapter, content: nextContent, title: nextTitle };
                    await mutateChapter(nextContent, false);
                    dispatch({ type: 'SET_AUTOSAVED' });
                }
            } catch (e) {
                dispatch({ type: 'SET_UNSAVED' });
                addMessage('error', '自动保存失败: ' + (e.response?.data?.detail || e.message));
            } finally {
                autosaveInFlightRef.current = false;
            }
        }, 1200);

        return () => {
            if (autosaveTimerRef.current) {
                window.clearTimeout(autosaveTimerRef.current);
                autosaveTimerRef.current = null;
            }
        };
    }, [
        state.unsavedChanges,
        projectId,
        chapterInfo.chapter,
        chapterInfo.chapter_title,
        manualContent,
        isStreamingForActiveChapter,
        lockedOnActiveChapter,
        isDiffReviewForActiveChapter,
        mutateChapter,
        dispatch,
        addMessage,
    ]);

    const clearDiffReview = useCallback(() => {
        setDiffReview(null);
        setDiffDecisions({});
    }, []);

    const stopStreaming = useCallback(() => {
        if (streamingRef.current?.timer) {
            streamingRef.current.timer();
        }
        streamingRef.current = null;
        setStreamingState({
            active: false,
            progress: 0,
            current: 0,
            total: 0
        });
    }, []);

    // 当资源管理器清空/删除当前章节时，主动回到空态，避免编辑区残留旧章节内容
    useEffect(() => {
        if (state.activeDocument) return;
        stopStreaming();
        clearDiffReview();
        setActiveCard(null);
        setChapterInfo({ chapter: null, chapter_title: null, content: null });
        setManualContent('');
        setStatus('idle');
    }, [clearDiffReview, state.activeDocument, stopStreaming]);

    const startStreamingDraft = useCallback((targetText, options = {}) => {
        const { onComplete, chapterKey } = options;
        const resolvedChapterKey = chapterKey ? String(chapterKey) : activeChapterKeyRef.current;
        stopStreaming();
        streamingChapterKeyRef.current = resolvedChapterKey;

        const safeText = targetText || '';
        if (!safeText) {
            setManualContentByChapter((prev) => ({ ...(prev || {}), [resolvedChapterKey]: '' }));
            if (activeChapterKeyRef.current === resolvedChapterKey) {
                setManualContent('');
