/**
 * 文枢 WenShape - 深度上下文感知的智能体小说创作系统
 * WenShape - Deep Context-Aware Agent-Based Novel Writing System
 *
 * Copyright © 2025-2026 WenShape Team
 * License: PolyForm Noncommercial License 1.0.0
 */

import { useState, useEffect, useRef, useCallback } from 'react';
import useSWR from 'swr';
import { motion, AnimatePresence } from 'framer-motion';
import { useParams, useNavigate } from 'react-router-dom';
import { sessionAPI, createWebSocket, draftsAPI, cardsAPI, projectsAPI, volumesAPI, memoryPackAPI } from '../api';
import { Button, Input } from '../components/ui/core';
import AgentsPanel from '../components/ide/panels/AgentsPanel';
import AgentStatusPanel from '../components/ide/AgentStatusPanel';
import { X, Loader2 } from 'lucide-react';
import { ChapterCreateDialog } from '../components/project/ChapterCreateDialog';
import { IDELayout } from '../components/ide/IDELayout';
import { IDEProvider } from '../context/IDEContext';
import { useIDE } from '../context/IDEContext';
import AnalysisReviewDialog from '../components/writing/AnalysisReviewDialog';
import PreWritingQuestionsDialog from '../components/PreWritingQuestionsDialog';
import StreamingDraftView from '../components/writing/StreamingDraftView';
import { buildLineDiff, applyDiffOpsWithDecisions } from '../lib/diffUtils';
import DiffReviewView from '../components/ide/DiffReviewView';
import SaveMenu from '../components/writing/SaveMenu';
import FanfictionView from './FanfictionView';
import logger from '../utils/logger';
import {
    fetchChapterContent,
    countChars,
    escapeRegExp,
    getSelectionStats,
    normalizeStars,
    parseListInput,
    formatListInput,
    formatRulesInput,
    hasDeletionIntent,
    stabilizeRevisionTail,
} from '../utils/writingSessionHelpers';

/**
 * WritingSessionContent - 写作会话主流程组件
 *
 * 统一的写作 IDE 界面，集成 AI 写作、编辑、分析等功能。
 * 使用 IDE Layout 提供三段式布局（活动栏、左侧面板、编辑区、右侧面板、底部状态栏）。
 *
 * 主要功能：
 * - 实时 WebSocket 连接管理和消息处理
 * - 章节内容编辑和版本管理
 * - AI 驱动的写作、编辑、分析建议
 * - 交互式对话和反馈流程
 * - 草稿保存和历史记录
 *
 * @component
 * @param {boolean} [isEmbedded=false] - 是否为嵌入模式（默认完整模式）
 * @returns {JSX.Element} 写作会话主界面
 */
function WritingSessionContent({ isEmbedded = false }) {
    const { projectId } = useParams();
    const navigate = useNavigate();
    const { state, dispatch } = useIDE();

    // ========================================================================
    // 项目和会话基本信息 / Project and Session Information
    // ========================================================================
    // 项目数据状态 / Project data from API
    const [project, setProject] = useState(null);
    const prevProjectIdRef = useRef(null);

    useEffect(() => {
        if (projectId) {
            projectsAPI.get(projectId).then(res => setProject(res.data));
            dispatch({ type: 'SET_PROJECT_ID', payload: projectId });
        }
    }, [projectId, dispatch]);

    // 项目切换时清理所有会话状态，防止数据污染
    // 使用 useRef 判断 projectId 是否真正变化，避免不必要的清理
    useEffect(() => {
        if (prevProjectIdRef.current && prevProjectIdRef.current !== projectId) {
            // 项目真正切换了：清理所有写作会话状态
            setDiffReview(null);
            setDiffDecisions({});
            setCurrentDraft(null);
            setManualContent('');
            setManualContentByChapter({});
            setMessagesByChapter({});
            setProgressEventsByChapter({});
            setDraftV1(null);
            setSceneBrief(null);
            setFeedback('');
            setChapterInfo({ chapter: null, chapter_title: null, content: null });
            setStatus('idle');
            setSelectionInfo({ start: 0, end: 0, text: '' });
            setAttachedSelection(null);
            setEditScope('document');
            setAiLockedChapter(null);
            if (streamingRef.current?.timer) {
                streamingRef.current.timer();
            }
            streamingRef.current = null;
            setStreamingState({ active: false, progress: 0, current: 0, total: 0 });
        }
        prevProjectIdRef.current = projectId;
    }, [projectId]);



    // UI State
    const [sidebarOpen, setSidebarOpen] = useState(true);
    const [showStartModal, setShowStartModal] = useState(true);
    const [showChapterDialog, setShowChapterDialog] = useState(false);
    const [chapters, setChapters] = useState([]);

    // Save/Analyze UI
    const [isSaving, setIsSaving] = useState(false);
    const [analysisDialogOpen, setAnalysisDialogOpen] = useState(false);
    const [analysisItems, setAnalysisItems] = useState([]);
    const [analysisLoading, setAnalysisLoading] = useState(false);
    const [analysisSaving, setAnalysisSaving] = useState(false);

    // Proposal State
    const [proposals, setProposals] = useState([]);
    const [rejectedItems, setRejectedItems] = useState([]);

    // Logic State
    const [status, setStatus] = useState('idle'); // idle, starting, editing, waiting_feedback, completed
    const [messagesByChapter, setMessagesByChapter] = useState({});
    const [progressEventsByChapter, setProgressEventsByChapter] = useState({});
    const [currentDraft, setCurrentDraft] = useState(null);
    const [manualContent, setManualContent] = useState(''); // Textarea content
    const [manualContentByChapter, setManualContentByChapter] = useState({});
    const [selectionInfo, setSelectionInfo] = useState({ start: 0, end: 0, text: '' });
    const [attachedSelection, setAttachedSelection] = useState(null); // { start, end, text }
    const [editScope, setEditScope] = useState('document'); // document | selection
    const [sceneBrief, setSceneBrief] = useState(null);
    const [draftV1, setDraftV1] = useState(null);
    const [feedback, setFeedback] = useState('');
    const [diffReview, setDiffReview] = useState(null);
    const [diffDecisions, setDiffDecisions] = useState({});
    const lastFeedbackRef = useRef('');
    const lastGeneratedByChapterRef = useRef({});
    const streamBufferByChapterRef = useRef({});
    const streamTextByChapterRef = useRef({});
    const streamFlushRafByChapterRef = useRef({});
    const serverStreamActiveRef = useRef(false);
    const serverStreamUsedRef = useRef(false);
    const streamingChapterKeyRef = useRef(null);

    const [showPreWriteDialog, setShowPreWriteDialog] = useState(false);
    const [preWriteQuestions, setPreWriteQuestions] = useState([]);
    const [pendingStartPayload, setPendingStartPayload] = useState(null);

    const manualContentByChapterRef = useRef(manualContentByChapter);
    useEffect(() => {
        manualContentByChapterRef.current = manualContentByChapter;
    }, [manualContentByChapter]);

    // AI 锁定章：写作/编辑进行中时，右侧面板锁死在该章节（中央可切换查看/手改其他章节）
    const [aiLockedChapter, setAiLockedChapter] = useState(null);
    const aiLockedChapterRef = useRef(aiLockedChapter);
    useEffect(() => {
        aiLockedChapterRef.current = aiLockedChapter;
    }, [aiLockedChapter]);

    // 轻提示（不打断、不强跳转）
    const [notice, setNotice] = useState(null);
    const noticeTimerRef = useRef(null);
    const pushNotice = useCallback((text) => {
        if (!text) return;
        const id = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        setNotice({ id, text: String(text) });
        if (noticeTimerRef.current) window.clearTimeout(noticeTimerRef.current);
        noticeTimerRef.current = window.setTimeout(() => setNotice(null), 2600);
    }, []);
    useEffect(() => {
        return () => {
            if (noticeTimerRef.current) window.clearTimeout(noticeTimerRef.current);
        };
    }, []);

    // WebSocket
    const wsRef = useRef(null);
    const traceWsRef = useRef(null);
    const wsStatusRef = useRef('disconnected');
    const [isGenerating, setIsGenerating] = useState(false);
    const streamingRef = useRef(null);
    const [streamingState, setStreamingState] = useState({
        active: false,
        progress: 0,
        current: 0,
        total: 0
    });

    // Trace Events for AgentTimeline
    const [traceEvents, setTraceEvents] = useState([]);
    const [agentTraces, setAgentTraces] = useState([]);

    // Chapter Info
    const [chapterInfo, setChapterInfo] = useState({
        chapter: null,
        chapter_title: null,
        content: null,
    });

    const NO_CHAPTER_KEY = '__no_chapter__';
    const activeChapterKey = chapterInfo.chapter ? String(chapterInfo.chapter) : NO_CHAPTER_KEY;

    const activeChapterKeyRef = useRef(activeChapterKey);
    useEffect(() => {
        activeChapterKeyRef.current = activeChapterKey;
    }, [activeChapterKey]);


    // Draft version state
    const [currentDraftVersion, setCurrentDraftVersion] = useState('v1');

    // Agent mode (for AgentStatusPanel)
    const [agentMode, setAgentMode] = useState('create'); // 'create' | 'edit'
    const [contextDebugByChapter, setContextDebugByChapter] = useState({});
    const [editContextMode, setEditContextMode] = useState('quick'); // quick | full

    const agentBusy =
        Boolean(aiLockedChapter) &&
        (Boolean(diffReview) ||
            showPreWriteDialog ||
            status === 'starting' ||
            status === 'waiting_user_input' ||
            isGenerating ||
            streamingState.active);

    const agentChapterKey = agentBusy
        ? String(aiLockedChapter)
        : activeChapterKey;

    const isStreamingForActiveChapter =
        streamingState.active && streamingChapterKeyRef.current === activeChapterKey;

    const isDiffReviewForActiveChapter =
        Boolean(diffReview) && String(diffReview?.chapterKey || '') === activeChapterKey;

    const lockedOnActiveChapter =
        agentBusy && String(aiLockedChapter || '') === activeChapterKey;

    const canUseWriter = countChars(
        agentBusy
            ? (manualContentByChapter[String(aiLockedChapter || '')] ?? '')
            : manualContent
    ) === 0;

    const messages = messagesByChapter[agentChapterKey] || [];
    const progressEvents = progressEventsByChapter[agentChapterKey] || [];
    const contextDebug = contextDebugByChapter[agentChapterKey] || null;

    useEffect(() => {
        if (!isGenerating && !canUseWriter && agentMode === 'create') {
            setAgentMode('edit');
        }
    }, [canUseWriter, agentMode, isGenerating]);

    useEffect(() => {
        if (agentMode !== 'edit') return;
        if (!attachedSelection?.text?.trim()) {
            if (editScope === 'selection') setEditScope('document');
            return;
        }
        if (editScope === 'document') setEditScope('selection');
    }, [agentMode, attachedSelection, editScope]);

    useEffect(() => {
        if (!aiLockedChapter) return;
        if (agentBusy) return;
        setAiLockedChapter(null);
    }, [aiLockedChapter, agentBusy]);

    useEffect(() => {
        if (!projectId) return;

        const wsController = createWebSocket(
            projectId,
            (data) => {
                const wsChapterKey = data?.chapter ? String(data.chapter) : NO_CHAPTER_KEY;
                if (data.type === 'start_ack') appendProgressEvent({ stage: 'session_start', message: '会话已启动' }, wsChapterKey);
                if (data.type === 'stream_start') {
                    if (wsChapterKey && wsChapterKey !== NO_CHAPTER_KEY) {
                        setAiLockedChapter(wsChapterKey);
                    }
                    streamingChapterKeyRef.current = wsChapterKey;
                    stopStreaming();
                    clearDiffReview();
                    serverStreamActiveRef.current = true;
                    serverStreamUsedRef.current = true;
                    streamBufferByChapterRef.current[wsChapterKey] = '';
                    streamTextByChapterRef.current[wsChapterKey] = '';
                    if (streamFlushRafByChapterRef.current[wsChapterKey]) {
                        window.cancelAnimationFrame(streamFlushRafByChapterRef.current[wsChapterKey]);
                        streamFlushRafByChapterRef.current[wsChapterKey] = null;
                    }
                    lastGeneratedByChapterRef.current[wsChapterKey] = true;
                    setManualContentByChapter((prev) => ({ ...(prev || {}), [wsChapterKey]: '' }));
                    if (activeChapterKeyRef.current === wsChapterKey) {
                        setManualContent('');
                    }
                    setIsGenerating(true);
                    setStreamingState({
                        active: true,
                        progress: 0,
                        current: 0,
                        total: data.total || 0
                    });
                }
                if (data.type === 'token' && typeof data.content === 'string') {
                    if (!serverStreamActiveRef.current) {
                        return;
                    }
                    streamBufferByChapterRef.current[wsChapterKey] =
                        (streamBufferByChapterRef.current[wsChapterKey] || '') + data.content;
                    if (!streamFlushRafByChapterRef.current[wsChapterKey]) {
                        streamFlushRafByChapterRef.current[wsChapterKey] = window.requestAnimationFrame(() => {
                            const buffered = streamBufferByChapterRef.current[wsChapterKey] || '';
                            const nextText = (streamTextByChapterRef.current[wsChapterKey] || '') + buffered;
                            streamTextByChapterRef.current[wsChapterKey] = nextText;
                            streamBufferByChapterRef.current[wsChapterKey] = '';
                            setManualContentByChapter((prev) => ({ ...(prev || {}), [wsChapterKey]: nextText }));
                            if (activeChapterKeyRef.current === wsChapterKey) {
                                setManualContent(nextText);
                            }
                            const current = nextText.length;
                            setStreamingState((prev) => ({
                                ...prev,
                                current,
                                progress: prev.total ? Math.round((current / prev.total) * 100) : prev.progress
                            }));
                            streamFlushRafByChapterRef.current[wsChapterKey] = null;
                        });
                    }
                }
                if (data.type === 'stream_end') {
                    if (streamFlushRafByChapterRef.current[wsChapterKey]) {
                        window.cancelAnimationFrame(streamFlushRafByChapterRef.current[wsChapterKey]);
                        streamFlushRafByChapterRef.current[wsChapterKey] = null;
                    }
                    const buffered = streamBufferByChapterRef.current[wsChapterKey] || '';
                    const combined = (streamTextByChapterRef.current[wsChapterKey] || '') + buffered;
                    streamTextByChapterRef.current[wsChapterKey] = combined;
                    streamBufferByChapterRef.current[wsChapterKey] = '';
                    const finalText = data.draft?.content || combined;
                    serverStreamActiveRef.current = false;
                    streamingChapterKeyRef.current = null;
                    setManualContentByChapter((prev) => ({ ...(prev || {}), [wsChapterKey]: finalText }));
                    if (activeChapterKeyRef.current === wsChapterKey) {
                        setManualContent(finalText);
                    }
                    setStreamingState({
                        active: false,
                        progress: 100,
                        current: finalText.length,
                        total: finalText.length
                    });
                    setIsGenerating(false);
                    if (activeChapterKeyRef.current === wsChapterKey) {
                        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(finalText) });
                        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });
                    } else {
                        pushNotice(`第 ${wsChapterKey} 章撰写完成，可切换查看。`);
                    }
                    if (data.draft) {
                        setCurrentDraft(data.draft);
                        setCurrentDraftVersion(data.draft.version || currentDraftVersion);
                    }
                    if (data.proposals) {
                        setProposals(data.proposals);
                    }
                    setStatus('waiting_feedback');
                    addMessage('assistant', '草稿已生成，可继续反馈或手动编辑。', wsChapterKey);
                }
                if (data.type === 'scene_brief') handleSceneBrief(data.data, wsChapterKey);
                if (data.type === 'draft_v1') handleDraftV1(data.data, wsChapterKey);
                if (data.type === 'final_draft') handleFinalDraft(data.data, wsChapterKey);
                if (data.type === 'error') addMessage('error', data.message, wsChapterKey);

                // Handle backend status updates (progress)
                if (data.status && data.message) {
                    if (data.stage) {
                        const event = {
                            id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
                            timestamp: data.timestamp || Date.now(),
                            stage: data.stage,
                            round: data.round,
                            message: data.message,
                            queries: data.queries || [],
                            hits: data.hits,
                            top_sources: data.top_sources || [],
                            stop_reason: data.stop_reason,
                            note: data.note
                        };
                        appendProgressEvent(event, wsChapterKey);
                    } else {

