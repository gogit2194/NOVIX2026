            }
            setIsGenerating(false);
            streamingChapterKeyRef.current = null;
            onComplete?.();
            return;
        }

        dispatch({ type: 'SET_UNSAVED' });
        setIsGenerating(true);
        const total = safeText.length;
        const charsPerSecond = Math.min(420, Math.max(180, Math.round(total / 3)));
        let index = 0;
        let lastTs = performance.now();
        let rafId = null;

        setManualContentByChapter((prev) => ({ ...(prev || {}), [resolvedChapterKey]: '' }));
        if (activeChapterKeyRef.current === resolvedChapterKey) {
            setManualContent('');
        }
        setStreamingState({
            active: true,
            progress: 0,
            current: 0,
            total
        });
        lastGeneratedByChapterRef.current[resolvedChapterKey] = true;

        const initialBurst = Math.min(total, Math.max(12, Math.floor(total * 0.03)));
        if (initialBurst > 0) {
            index = initialBurst;
            const burstText = safeText.slice(0, index);
            setManualContentByChapter((prev) => ({ ...(prev || {}), [resolvedChapterKey]: burstText }));
            if (activeChapterKeyRef.current === resolvedChapterKey) {
                setManualContent(burstText);
            }
            setStreamingState({
                active: index < total,
                progress: Math.round((index / total) * 100),
                current: index,
                total
            });
        }

        const tick = (ts) => {
            const delta = Math.max(0, ts - lastTs);
            const increment = Math.max(1, Math.floor((delta / 1000) * charsPerSecond));
            index = Math.min(total, index + increment);
            lastTs = ts;

            const partial = safeText.slice(0, index);
            setManualContentByChapter((prev) => ({ ...(prev || {}), [resolvedChapterKey]: partial }));
            if (activeChapterKeyRef.current === resolvedChapterKey) {
                setManualContent(partial);
            }
            setStreamingState({
                active: index < total,
                progress: Math.round((index / total) * 100),
                current: index,
                total
            });

            if (index >= total) {
                streamingRef.current = null;
                setIsGenerating(false);
                streamingChapterKeyRef.current = null;
                if (activeChapterKeyRef.current === resolvedChapterKey) {
                    dispatch({ type: 'SET_WORD_COUNT', payload: countChars(safeText) });
                    dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });
                } else {
                    pushNotice(`第 ${resolvedChapterKey} 章撰写完成，可切换查看。`);
                }
                onComplete?.();
                return;
            }

            rafId = window.requestAnimationFrame(tick);
        };

        rafId = window.requestAnimationFrame(tick);
        streamingRef.current = {
            timer: () => {
                if (rafId) window.cancelAnimationFrame(rafId);
            }
        };
    }, [dispatch, stopStreaming, pushNotice]);

    useEffect(() => {
        return () => {
            stopStreaming();
        };
    }, [stopStreaming]);

    // 监听 Context 中的文档选择（章节或卡片）
    useEffect(() => {
        if (!state.activeDocument) return;

        if (state.activeDocument.type === 'chapter' && state.activeDocument.id) {
            setActiveCard(null); // Clear card state
            const presetTitle =
                state.activeDocument.data?.title ||
                state.activeDocument.data?.chapter_title ||
                state.activeDocument.title ||
                state.activeDocument.chapter_title ||
                '';
            handleChapterSelect(state.activeDocument.id, presetTitle);
        } else if (['character', 'world'].includes(state.activeDocument.type)) {
            // Switch to Card Mode
            stopStreaming();
            clearDiffReview();
            setChapterInfo({ chapter: null, chapter_title: null, content: null });

            // Initial setup with basic info
            const cardData = state.activeDocument.data || { name: state.activeDocument.id };
            const originalName = state.activeDocument.id || cardData.name || '';
            const isNew = Boolean(state.activeDocument.isNew || cardData.isNew || !originalName);
            setActiveCard({
                ...cardData,
                type: state.activeDocument.type,
                isNew,
                originalName
            });
            setCardForm({
                name: cardData.name || '',
                description: '',
                aliases: formatListInput(cardData.aliases),
                stars: normalizeStars(cardData.stars),
                category: cardData.category || '',
                rules: formatRulesInput(cardData.rules),
                immutable: cardData.immutable === true ? 'true' : cardData.immutable === false ? 'false' : 'unset'
            });
            setStatus('card_editing');

            // Fetch full details
            const fetchCardDetails = async () => {
                try {
                    let resp;
                    if (state.activeDocument.type === 'character') {
                        resp = await cardsAPI.getCharacter(projectId, state.activeDocument.id);
                    } else {
                        resp = await cardsAPI.getWorld(projectId, state.activeDocument.id);
                    }
                    const fullData = resp?.data || {};
                    setCardForm({
                        name: fullData.name || cardData.name || '',
                        description: fullData.description || '',
                        aliases: formatListInput(fullData.aliases),
                        stars: normalizeStars(fullData.stars),
                        category: fullData.category || '',
                        rules: formatRulesInput(fullData.rules),
                        immutable: fullData.immutable === true ? 'true' : fullData.immutable === false ? 'false' : 'unset'
                    });
                } catch (e) {
                    logger.error("Failed to fetch card details", e);
                    addMessage('error', '加载卡片详情失败: ' + e.message);
                }
            };

            if (state.activeDocument.id) {
                fetchCardDetails();
            }
        }
    }, [state.activeDocument, stopStreaming, clearDiffReview, projectId]);

    // Handlers
    const handleStart = async (chapter, mode, instruction = null) => {
        if (!chapter) {
            alert('请先选择章节');
            return;
        }
        const chapterKey = String(chapter);
        setAiLockedChapter(chapterKey);
        setManualContentByChapter((prev) => {
            const next = { ...(prev || {}) };
            if (next[chapterKey] === undefined) {
                next[chapterKey] = manualContent;
            }
            return next;
        });

        stopStreaming();
        clearDiffReview();
        serverStreamActiveRef.current = false;
        serverStreamUsedRef.current = false;
        setStatus('starting');
        setIsGenerating(true);
        setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: null }));
        setProgressEventsByChapter((prev) => ({ ...(prev || {}), [chapterKey]: [] }));

        setAgentMode('create');
        appendProgressEvent({ stage: 'session_start', message: '正在准备上下文…' }, chapterKey);

        try {
            const payload = {
                chapter: String(chapter),
                chapter_title: chapterInfo.chapter_title || `章节 ${chapter}`,
                chapter_goal: instruction || 'Auto-generation based on context',
                target_word_count: 3000
            };

            const resp = await sessionAPI.start(projectId, payload);
            const result = resp.data;

            if (!result.success) {
                throw new Error(result.error || '会话启动失败');
            }
            if (result.status === 'waiting_user_input' && result.questions?.length) {
                if (result.scene_brief) {
                    setSceneBrief(result.scene_brief);
                    appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: result.scene_brief }, chapterKey);
                }
                setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: result.context_debug || null }));
                setPreWriteQuestions(result.questions);
                setPendingStartPayload(payload);
                setShowPreWriteDialog(true);
                setStatus('waiting_user_input');
                setIsGenerating(false);
                return;
            }

            if (result.scene_brief) {
                setSceneBrief(result.scene_brief);
                appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: result.scene_brief }, chapterKey);
            }
            setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: result.context_debug || null }));

            if (result.draft_v1) {
                setDraftV1(result.draft_v1);
            }

            const finalDraft = result.draft_v2 || result.draft_v1;
            const shouldUseHttpDraft = !serverStreamActiveRef.current && !serverStreamUsedRef.current;
            if (finalDraft && shouldUseHttpDraft) {
                setCurrentDraft(finalDraft);
                setCurrentDraftVersion(result.draft_v2 ? 'v2' : 'v1');
                startStreamingDraft(finalDraft.content || '', { chapterKey });
            } else if (shouldUseHttpDraft) {
                setIsGenerating(false);
            }

            if (result.proposals) {
                setProposals(result.proposals);
            }

            setStatus('waiting_feedback');
            if (!serverStreamActiveRef.current && !serverStreamUsedRef.current) {
                addMessage('assistant', '草稿已生成，可继续反馈或手动编辑。', chapterKey);
            }
        } catch (e) {
            addMessage('error', '启动失败: ' + e.message, chapterKey);
            setStatus('idle');
            setIsGenerating(false);
        }
    };

    const handlePreWriteConfirm = async (answers) => {
        if (!pendingStartPayload) return;
        const startPayload = pendingStartPayload;
        const chapterKey = startPayload?.chapter ? String(startPayload.chapter) : activeChapterKey;
        if (chapterKey && chapterKey !== NO_CHAPTER_KEY) {
            setAiLockedChapter(chapterKey);
        }
        setShowPreWriteDialog(false);
        stopStreaming();
        clearDiffReview();
        serverStreamActiveRef.current = false;
        serverStreamUsedRef.current = false;
        setIsGenerating(true);

        try {
            const resp = await sessionAPI.answerQuestions(projectId, {
                ...startPayload,
                answers
            });
            const result = resp.data;

            if (!result.success) {
                throw new Error(result.error || '回答问题失败');
            }

            if (result.status === 'waiting_user_input' && result.questions?.length) {
                setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: result.context_debug || null }));
                if (result.scene_brief) {
                    setSceneBrief(result.scene_brief);
                    appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: result.scene_brief }, chapterKey);
                }
                setPreWriteQuestions(result.questions);
                setPendingStartPayload(startPayload);
                setShowPreWriteDialog(true);
                setStatus('waiting_user_input');
                setIsGenerating(false);
                return;
            }

            if (result.scene_brief) {
                setSceneBrief(result.scene_brief);
                appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: result.scene_brief }, chapterKey);
            }
            setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: result.context_debug || null }));
            if (result.draft_v1) {
                setDraftV1(result.draft_v1);
            }

            const finalDraft = result.draft_v2 || result.draft_v1;
            const shouldUseHttpDraft = !serverStreamActiveRef.current && !serverStreamUsedRef.current;
            if (finalDraft && shouldUseHttpDraft) {
                setCurrentDraft(finalDraft);
                setCurrentDraftVersion(result.draft_v2 ? 'v2' : 'v1');
                startStreamingDraft(finalDraft.content || '', { chapterKey });
            } else if (shouldUseHttpDraft) {
                setIsGenerating(false);
            }

            if (result.proposals) {
                setProposals(result.proposals);
            }

            setStatus('waiting_feedback');
            if (!serverStreamActiveRef.current && !serverStreamUsedRef.current) {
                addMessage('assistant', '草稿已生成，可继续反馈或手动编辑。', chapterKey);
            }
            setPendingStartPayload(null);
        } catch (e) {
            addMessage('error', '生成失败: ' + e.message, chapterKey);
            setStatus('idle');
            setIsGenerating(false);
        }
    };

    const handlePreWriteSkip = () => {
        handlePreWriteConfirm([]);
    };

    const handleSceneBrief = (data, chapterOverride = null) => {
        setSceneBrief(data);
        appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: data }, chapterOverride);
    };

    const handleDraftV1 = (data, chapterOverride = null) => {
        if (serverStreamActiveRef.current || serverStreamUsedRef.current) {
            return;
        }
        setDraftV1(data);
        clearDiffReview();
        const chapterKey = chapterOverride ? String(chapterOverride) : activeChapterKeyRef.current;
        if (chapterKey && chapterKey !== NO_CHAPTER_KEY) {
            setAiLockedChapter(chapterKey);
        }
        startStreamingDraft(data.content || '', {
            chapterKey,
        });
        setStatus('waiting_feedback');
        addMessage('assistant', '草稿已生成，可继续反馈或手动编辑。', chapterOverride);
    };

    const handleFinalDraft = (data, chapterOverride = null) => {
        if (serverStreamActiveRef.current || serverStreamUsedRef.current) {
            return;
        }
        setCurrentDraft(data);
        clearDiffReview();
        const chapterKey = chapterOverride ? String(chapterOverride) : activeChapterKeyRef.current;
        if (chapterKey && chapterKey !== NO_CHAPTER_KEY) {
            setAiLockedChapter(chapterKey);
        }
        startStreamingDraft(data.content || '', {
            chapterKey,
        });
        setStatus('completed');
        addMessage('assistant', '终稿已完成。', chapterOverride);
    };

    const handleSubmitFeedback = async (feedbackOverride) => {
        const textToSubmit = typeof feedbackOverride === 'string' ? feedbackOverride : feedback;
        if (!textToSubmit?.trim()) return;

        try {
            const normalizeLineEndings = (text) => String(text || '').replace(/\r\n/g, '\n');
            const baseContent = normalizeLineEndings(manualContent);
            const chapterKey = chapterInfo.chapter ? String(chapterInfo.chapter) : activeChapterKey;
            if (chapterKey && chapterKey !== NO_CHAPTER_KEY) {
                setAiLockedChapter(chapterKey);
            }
            setIsGenerating(true);
            setStatus('editing');

            setAgentMode('edit');

            stopStreaming();
            clearDiffReview();
            lastFeedbackRef.current = textToSubmit;

            addMessage('user', `修改指令：${textToSubmit}`);
            appendProgressEvent({ stage: 'edit_suggest', message: '正在生成差异修改建议…' });
            setFeedback('');

            const payload = {
                chapter: chapterInfo.chapter ? String(chapterInfo.chapter) : null,
                content: baseContent,
                instruction: textToSubmit,
                context_mode: editContextMode,
