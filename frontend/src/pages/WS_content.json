{"content": "/**\n * 文枢 WenShape - 深度上下文感知的智能体小说创作系统\n * WenShape - Deep Context-Aware Agent-Based Novel Writing System\n *\n * Copyright © 2025-2026 WenShape Team\n * License: PolyForm Noncommercial License 1.0.0\n */\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport useSWR from 'swr';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { sessionAPI, createWebSocket, draftsAPI, cardsAPI, projectsAPI, volumesAPI, memoryPackAPI } from '../api';\nimport { Button, Input } from '../components/ui/core';\nimport AgentsPanel from '../components/ide/panels/AgentsPanel';\nimport AgentStatusPanel from '../components/ide/AgentStatusPanel';\nimport { X, Loader2 } from 'lucide-react';\nimport { ChapterCreateDialog } from '../components/project/ChapterCreateDialog';\nimport { IDELayout } from '../components/ide/IDELayout';\nimport { IDEProvider } from '../context/IDEContext';\nimport { useIDE } from '../context/IDEContext';\nimport AnalysisReviewDialog from '../components/writing/AnalysisReviewDialog';\nimport PreWritingQuestionsDialog from '../components/PreWritingQuestionsDialog';\nimport StreamingDraftView from '../components/writing/StreamingDraftView';\nimport { buildLineDiff, applyDiffOpsWithDecisions } from '../lib/diffUtils';\nimport DiffReviewView from '../components/ide/DiffReviewView';\nimport SaveMenu from '../components/writing/SaveMenu';\nimport FanfictionView from './FanfictionView';\nimport logger from '../utils/logger';\nimport {\n    fetchChapterContent,\n    countChars,\n    escapeRegExp,\n    getSelectionStats,\n    normalizeStars,\n    parseListInput,\n    formatListInput,\n    formatRulesInput,\n    hasDeletionIntent,\n    stabilizeRevisionTail,\n} from '../utils/writingSessionHelpers';\n\n/**\n * WritingSessionContent - 写作会话主流程组件\n *\n * 统一的写作 IDE 界面，集成 AI 写作、编辑、分析等功能。\n * 使用 IDE Layout 提供三段式布局（活动栏、左侧面板、编辑区、右侧面板、底部状态栏）。\n *\n * 主要功能：\n * - 实时 WebSocket 连接管理和消息处理\n * - 章节内容编辑和版本管理\n * - AI 驱动的写作、编辑、分析建议\n * - 交互式对话和反馈流程\n * - 草稿保存和历史记录\n *\n * @component\n * @param {boolean} [isEmbedded=false] - 是否为嵌入模式（默认完整模式）\n * @returns {JSX.Element} 写作会话主界面\n */\nfunction WritingSessionContent({ isEmbedded = false }) {\n    const { projectId } = useParams();\n    const navigate = useNavigate();\n    const { state, dispatch } = useIDE();\n\n    // ========================================================================\n    // 项目和会话基本信息 / Project and Session Information\n    // ========================================================================\n    // 项目数据状态 / Project data from API\n    const [project, setProject] = useState(null);\n    const prevProjectIdRef = useRef(null);\n\n    useEffect(() => {\n        if (projectId) {\n            projectsAPI.get(projectId).then(res => setProject(res.data));\n            dispatch({ type: 'SET_PROJECT_ID', payload: projectId });\n        }\n    }, [projectId, dispatch]);\n\n    // 项目切换时清理所有会话状态，防止数据污染\n    // 使用 useRef 判断 projectId 是否真正变化，避免不必要的清理\n    useEffect(() => {\n        if (prevProjectIdRef.current && prevProjectIdRef.current !== projectId) {\n            // 项目真正切换了：清理所有写作会话状态\n            setDiffReview(null);\n            setDiffDecisions({});\n            setCurrentDraft(null);\n            setManualContent('');\n            setManualContentByChapter({});\n            setMessagesByChapter({});\n            setProgressEventsByChapter({});\n            setDraftV1(null);\n            setSceneBrief(null);\n            setFeedback('');\n            setChapterInfo({ chapter: null, chapter_title: null, content: null });\n            setStatus('idle');\n            setSelectionInfo({ start: 0, end: 0, text: '' });\n            setAttachedSelection(null);\n            setEditScope('document');\n            setAiLockedChapter(null);\n            if (streamingRef.current?.timer) {\n                streamingRef.current.timer();\n            }\n            streamingRef.current = null;\n            setStreamingState({ active: false, progress: 0, current: 0, total: 0 });\n        }\n        prevProjectIdRef.current = projectId;\n    }, [projectId]);\n\n\n\n    // UI State\n    const [sidebarOpen, setSidebarOpen] = useState(true);\n    const [showStartModal, setShowStartModal] = useState(true);\n    const [showChapterDialog, setShowChapterDialog] = useState(false);\n    const [chapters, setChapters] = useState([]);\n\n    // Save/Analyze UI\n    const [isSaving, setIsSaving] = useState(false);\n    const [analysisDialogOpen, setAnalysisDialogOpen] = useState(false);\n    const [analysisItems, setAnalysisItems] = useState([]);\n    const [analysisLoading, setAnalysisLoading] = useState(false);\n    const [analysisSaving, setAnalysisSaving] = useState(false);\n\n    // Proposal State\n    const [proposals, setProposals] = useState([]);\n    const [rejectedItems, setRejectedItems] = useState([]);\n\n    // Logic State\n    const [status, setStatus] = useState('idle'); // idle, starting, editing, waiting_feedback, completed\n    const [messagesByChapter, setMessagesByChapter] = useState({});\n    const [progressEventsByChapter, setProgressEventsByChapter] = useState({});\n    const [currentDraft, setCurrentDraft] = useState(null);\n    const [manualContent, setManualContent] = useState(''); // Textarea content\n    const [manualContentByChapter, setManualContentByChapter] = useState({});\n    const [selectionInfo, setSelectionInfo] = useState({ start: 0, end: 0, text: '' });\n    const [attachedSelection, setAttachedSelection] = useState(null); // { start, end, text }\n    const [editScope, setEditScope] = useState('document'); // document | selection\n    const [sceneBrief, setSceneBrief] = useState(null);\n    const [draftV1, setDraftV1] = useState(null);\n    const [feedback, setFeedback] = useState('');\n    const [diffReview, setDiffReview] = useState(null);\n    const [diffDecisions, setDiffDecisions] = useState({});\n    const lastFeedbackRef = useRef('');\n    const lastGeneratedByChapterRef = useRef({});\n    const streamBufferByChapterRef = useRef({});\n    const streamTextByChapterRef = useRef({});\n    const streamFlushRafByChapterRef = useRef({});\n    const serverStreamActiveRef = useRef(false);\n    const serverStreamUsedRef = useRef(false);\n    const streamingChapterKeyRef = useRef(null);\n\n    const [showPreWriteDialog, setShowPreWriteDialog] = useState(false);\n    const [preWriteQuestions, setPreWriteQuestions] = useState([]);\n    const [pendingStartPayload, setPendingStartPayload] = useState(null);\n\n    const manualContentByChapterRef = useRef(manualContentByChapter);\n    useEffect(() => {\n        manualContentByChapterRef.current = manualContentByChapter;\n    }, [manualContentByChapter]);\n\n    // AI 锁定章：写作/编辑进行中时，右侧面板锁死在该章节（中央可切换查看/手改其他章节）\n    const [aiLockedChapter, setAiLockedChapter] = useState(null);\n    const aiLockedChapterRef = useRef(aiLockedChapter);\n    useEffect(() => {\n        aiLockedChapterRef.current = aiLockedChapter;\n    }, [aiLockedChapter]);\n\n    // 轻提示（不打断、不强跳转）\n    const [notice, setNotice] = useState(null);\n    const noticeTimerRef = useRef(null);\n    const pushNotice = useCallback((text) => {\n        if (!text) return;\n        const id = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n        setNotice({ id, text: String(text) });\n        if (noticeTimerRef.current) window.clearTimeout(noticeTimerRef.current);\n        noticeTimerRef.current = window.setTimeout(() => setNotice(null), 2600);\n    }, []);\n    useEffect(() => {\n        return () => {\n            if (noticeTimerRef.current) window.clearTimeout(noticeTimerRef.current);\n        };\n    }, []);\n\n    // WebSocket\n    const wsRef = useRef(null);\n    const traceWsRef = useRef(null);\n    const wsStatusRef = useRef('disconnected');\n    const [isGenerating, setIsGenerating] = useState(false);\n    const streamingRef = useRef(null);\n    const [streamingState, setStreamingState] = useState({\n        active: false,\n        progress: 0,\n        current: 0,\n        total: 0\n    });\n\n    // Trace Events for AgentTimeline\n    const [traceEvents, setTraceEvents] = useState([]);\n    const [agentTraces, setAgentTraces] = useState([]);\n\n    // Chapter Info\n    const [chapterInfo, setChapterInfo] = useState({\n        chapter: null,\n        chapter_title: null,\n        content: null,\n    });\n\n    const NO_CHAPTER_KEY = '__no_chapter__';\n    const activeChapterKey = chapterInfo.chapter ? String(chapterInfo.chapter) : NO_CHAPTER_KEY;\n\n    const activeChapterKeyRef = useRef(activeChapterKey);\n    useEffect(() => {\n        activeChapterKeyRef.current = activeChapterKey;\n    }, [activeChapterKey]);\n\n\n    // Draft version state\n    const [currentDraftVersion, setCurrentDraftVersion] = useState('v1');\n\n    // Agent mode (for AgentStatusPanel)\n    const [agentMode, setAgentMode] = useState('create'); // 'create' | 'edit'\n    const [contextDebugByChapter, setContextDebugByChapter] = useState({});\n    const [editContextMode, setEditContextMode] = useState('quick'); // quick | full\n\n    const agentBusy =\n        Boolean(aiLockedChapter) &&\n        (Boolean(diffReview) ||\n            showPreWriteDialog ||\n            status === 'starting' ||\n            status === 'waiting_user_input' ||\n            isGenerating ||\n            streamingState.active);\n\n    const agentChapterKey = agentBusy\n        ? String(aiLockedChapter)\n        : activeChapterKey;\n\n    const isStreamingForActiveChapter =\n        streamingState.active && streamingChapterKeyRef.current === activeChapterKey;\n\n    const isDiffReviewForActiveChapter =\n        Boolean(diffReview) && String(diffReview?.chapterKey || '') === activeChapterKey;\n\n    const lockedOnActiveChapter =\n        agentBusy && String(aiLockedChapter || '') === activeChapterKey;\n\n    const canUseWriter = countChars(\n        agentBusy\n            ? (manualContentByChapter[String(aiLockedChapter || '')] ?? '')\n            : manualContent\n    ) === 0;\n\n    const messages = messagesByChapter[agentChapterKey] || [];\n    const progressEvents = progressEventsByChapter[agentChapterKey] || [];\n    const contextDebug = contextDebugByChapter[agentChapterKey] || null;\n\n    useEffect(() => {\n        if (!isGenerating && !canUseWriter && agentMode === 'create') {\n            setAgentMode('edit');\n        }\n    }, [canUseWriter, agentMode, isGenerating]);\n\n    useEffect(() => {\n        if (agentMode !== 'edit') return;\n        if (!attachedSelection?.text?.trim()) {\n            if (editScope === 'selection') setEditScope('document');\n            return;\n        }\n        if (editScope === 'document') setEditScope('selection');\n    }, [agentMode, attachedSelection, editScope]);\n\n    useEffect(() => {\n        if (!aiLockedChapter) return;\n        if (agentBusy) return;\n        setAiLockedChapter(null);\n    }, [aiLockedChapter, agentBusy]);\n\n    useEffect(() => {\n        if (!projectId) return;\n\n        const wsController = createWebSocket(\n            projectId,\n            (data) => {\n                const wsChapterKey = data?.chapter ? String(data.chapter) : NO_CHAPTER_KEY;\n                if (data.type === 'start_ack') appendProgressEvent({ stage: 'session_start', message: '会话已启动' }, wsChapterKey);\n                if (data.type === 'stream_start') {\n                    if (wsChapterKey && wsChapterKey !== NO_CHAPTER_KEY) {\n                        setAiLockedChapter(wsChapterKey);\n                    }\n                    streamingChapterKeyRef.current = wsChapterKey;\n                    stopStreaming();\n                    clearDiffReview();\n                    serverStreamActiveRef.current = true;\n                    serverStreamUsedRef.current = true;\n                    streamBufferByChapterRef.current[wsChapterKey] = '';\n                    streamTextByChapterRef.current[wsChapterKey] = '';\n                    if (streamFlushRafByChapterRef.current[wsChapterKey]) {\n                        window.cancelAnimationFrame(streamFlushRafByChapterRef.current[wsChapterKey]);\n                        streamFlushRafByChapterRef.current[wsChapterKey] = null;\n                    }\n                    lastGeneratedByChapterRef.current[wsChapterKey] = true;\n                    setManualContentByChapter((prev) => ({ ...(prev || {}), [wsChapterKey]: '' }));\n                    if (activeChapterKeyRef.current === wsChapterKey) {\n                        setManualContent('');\n                    }\n                    setIsGenerating(true);\n                    setStreamingState({\n                        active: true,\n                        progress: 0,\n                        current: 0,\n                        total: data.total || 0\n                    });\n                }\n                if (data.type === 'token' && typeof data.content === 'string') {\n                    if (!serverStreamActiveRef.current) {\n                        return;\n                    }\n                    streamBufferByChapterRef.current[wsChapterKey] =\n                        (streamBufferByChapterRef.current[wsChapterKey] || '') + data.content;\n                    if (!streamFlushRafByChapterRef.current[wsChapterKey]) {\n                        streamFlushRafByChapterRef.current[wsChapterKey] = window.requestAnimationFrame(() => {\n                            const buffered = streamBufferByChapterRef.current[wsChapterKey] || '';\n                            const nextText = (streamTextByChapterRef.current[wsChapterKey] || '') + buffered;\n                            streamTextByChapterRef.current[wsChapterKey] = nextText;\n                            streamBufferByChapterRef.current[wsChapterKey] = '';\n                            setManualContentByChapter((prev) => ({ ...(prev || {}), [wsChapterKey]: nextText }));\n                            if (activeChapterKeyRef.current === wsChapterKey) {\n                                setManualContent(nextText);\n                            }\n                            const current = nextText.length;\n                            setStreamingState((prev) => ({\n                                ...prev,\n                                current,\n                                progress: prev.total ? Math.round((current / prev.total) * 100) : prev.progress\n                            }));\n                            streamFlushRafByChapterRef.current[wsChapterKey] = null;\n                        });\n                    }\n                }\n                if (data.type === 'stream_end') {\n                    if (streamFlushRafByChapterRef.current[wsChapterKey]) {\n                        window.cancelAnimationFrame(streamFlushRafByChapterRef.current[wsChapterKey]);\n                        streamFlushRafByChapterRef.current[wsChapterKey] = null;\n                    }\n                    const buffered = streamBufferByChapterRef.current[wsChapterKey] || '';\n                    const combined = (streamTextByChapterRef.current[wsChapterKey] || '') + buffered;\n                    streamTextByChapterRef.current[wsChapterKey] = combined;\n                    streamBufferByChapterRef.current[wsChapterKey] = '';\n                    const finalText = data.draft?.content || combined;\n                    serverStreamActiveRef.current = false;\n                    streamingChapterKeyRef.current = null;\n                    setManualContentByChapter((prev) => ({ ...(prev || {}), [wsChapterKey]: finalText }));\n                    if (activeChapterKeyRef.current === wsChapterKey) {\n                        setManualContent(finalText);\n                    }\n                    setStreamingState({\n                        active: false,\n                        progress: 100,\n                        current: finalText.length,\n                        total: finalText.length\n                    });\n                    setIsGenerating(false);\n                    if (activeChapterKeyRef.current === wsChapterKey) {\n                        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(finalText) });\n                        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });\n                    } else {\n                        pushNotice(`第 ${wsChapterKey} 章撰写完成，可切换查看。`);\n                    }\n                    if (data.draft) {\n                        setCurrentDraft(data.draft);\n                        setCurrentDraftVersion(data.draft.version || currentDraftVersion);\n                    }\n                    if (data.proposals) {\n                        setProposals(data.proposals);\n                    }\n                    setStatus('waiting_feedback');\n                    addMessage('assistant', '草稿已生成，可继续反馈或手动编辑。', wsChapterKey);\n                }\n                if (data.type === 'scene_brief') handleSceneBrief(data.data, wsChapterKey);\n                if (data.type === 'draft_v1') handleDraftV1(data.data, wsChapterKey);\n                if (data.type === 'final_draft') handleFinalDraft(data.data, wsChapterKey);\n                if (data.type === 'error') addMessage('error', data.message, wsChapterKey);\n\n                // Handle backend status updates (progress)\n                if (data.status && data.message) {\n                    if (data.stage) {\n                        const event = {\n                            id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,\n                            timestamp: data.timestamp || Date.now(),\n                            stage: data.stage,\n                            round: data.round,\n                            message: data.message,\n                            queries: data.queries || [],\n                            hits: data.hits,\n                            top_sources: data.top_sources || [],\n                            stop_reason: data.stop_reason,\n                            note: data.note\n                        };\n                        appendProgressEvent(event, wsChapterKey);\n                    } else {\n                        appendProgressEvent({ stage: 'system', message: data.message, note: data.note }, wsChapterKey);\n                    }\n                }\n            },\n            {\n                onStatus: (status) => {\n                    if (wsStatusRef.current !== status) {\n                        if (status === 'reconnecting') {\n                            appendProgressEvent({ stage: 'connection', message: '连接中断，正在重连…' }, NO_CHAPTER_KEY);\n                        }\n                        if (status === 'connected' && wsStatusRef.current === 'reconnecting') {\n                            appendProgressEvent({ stage: 'connection', message: '连接已恢复' }, NO_CHAPTER_KEY);\n                        }\n                        if (status === 'disconnected') {\n                            appendProgressEvent({ stage: 'connection', message: '连接已断开' }, NO_CHAPTER_KEY);\n                        }\n                    }\n\n                    wsStatusRef.current = status;\n                }\n            }\n        );\n\n        wsRef.current = wsController;\n\n        // Connect to Trace WebSocket for AgentTimeline\n        const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n        const wsHost = window.location.host;\n        const traceWs = new WebSocket(`${wsProtocol}://${wsHost}/ws/trace`);\n\n        traceWs.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            if (data.type === 'trace_event' && data.payload) {\n                setTraceEvents(prev => [...prev.slice(-99), data.payload]); // Keep last 100 events\n            }\n            if (data.type === 'agent_trace_update' && data.payload) {\n                setAgentTraces(prev => {\n                    const existing = prev.findIndex(t => t.agent_name === data.payload.agent_name);\n                    if (existing >= 0) {\n                        const updated = [...prev];\n                        updated[existing] = data.payload;\n                        return updated;\n                    }\n                    return [...prev, data.payload];\n                });\n            }\n        };\n\n        traceWsRef.current = traceWs;\n\n        return () => {\n            if (wsController) wsController.close();\n            if (traceWs) traceWs.close();\n        };\n    }, [projectId]);\n\n    // Card State\n    const [activeCard, setActiveCard] = useState(null);\n    const [cardForm, setCardForm] = useState({\n        name: '',\n        description: '',\n        aliases: '',\n        stars: 1,\n        category: '',\n        rules: '',\n        immutable: 'unset'\n    });\n\n    // SWR for Chapter Content\n    const { data: loadedContent, mutate: mutateChapter } = useSWR(\n        chapterInfo.chapter ? ['chapter', projectId, chapterInfo.chapter] : null,\n        fetchChapterContent,\n        {\n            revalidateOnFocus: false,\n            dedupingInterval: 60000, // Cache for 1 minute before checking again\n            keepPreviousData: false // Don't show previous chapter data while loading (we handle this with manualContent update)\n        }\n    );\n\n    const { data: volumes = [] } = useSWR(\n        projectId ? ['volumes', projectId] : null,\n        () => volumesAPI.list(projectId).then(res => res.data),\n        { revalidateOnFocus: false }\n    );\n\n    const memoryPackChapter = agentBusy ? aiLockedChapter : chapterInfo.chapter;\n    const { data: memoryPackStatus } = useSWR(\n        projectId && memoryPackChapter ? ['memory-pack', projectId, memoryPackChapter] : null,\n        () => memoryPackAPI.getStatus(projectId, memoryPackChapter).then(res => res.data),\n        { revalidateOnFocus: false, refreshInterval: 5000 }\n    );\n\n    // Sync SWR data to manualContent\n    useEffect(() => {\n        if (loadedContent === undefined || state.unsavedChanges) {\n            return;\n        }\n        if (isStreamingForActiveChapter || lockedOnActiveChapter || isDiffReviewForActiveChapter) {\n            return;\n        }\n\n        const chapterKey = activeChapterKey;\n        if (chapterKey === NO_CHAPTER_KEY) return;\n\n        const lastGeneratedForChapter = Boolean(lastGeneratedByChapterRef.current?.[chapterKey]);\n        if (lastGeneratedForChapter && manualContent && !(loadedContent || '').trim()) {\n            return;\n        }\n\n        setManualContentByChapter((prev) => ({ ...(prev || {}), [chapterKey]: loadedContent }));\n        setManualContent(loadedContent);\n        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(loadedContent) });\n        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });\n        lastGeneratedByChapterRef.current[chapterKey] = false;\n        // Only center cursor if we just switched chapters (optional optimization)\n        // dispatch({ type: 'SET_CURSOR_POSITION', payload: { line: 1, column: 1 } });\n    }, [\n        loadedContent,\n        dispatch,\n        manualContent,\n        state.unsavedChanges,\n        activeChapterKey,\n        NO_CHAPTER_KEY,\n        isStreamingForActiveChapter,\n        lockedOnActiveChapter,\n        isDiffReviewForActiveChapter,\n    ]);\n\n    useEffect(() => {\n        loadChapters();\n    }, [projectId]);\n\n    useEffect(() => {\n        let active = true;\n        const loadTitle = async () => {\n            if (!projectId || !chapterInfo.chapter) return;\n            if (chapterInfo.chapter_title && chapterInfo.chapter_title.trim()) return;\n            try {\n                const summaryResp = await draftsAPI.getSummary(projectId, chapterInfo.chapter);\n                const summary = summaryResp.data || {};\n                const title = summary.title || summary.chapter_title || '';\n                if (active && title) {\n                    setChapterInfo((prev) => ({ ...prev, chapter_title: title }));\n                }\n            } catch (e) {\n                // ignore missing summary\n            }\n        };\n        loadTitle();\n        return () => {\n            active = false;\n        };\n    }, [projectId, chapterInfo.chapter, chapterInfo.chapter_title]);\n\n    // 监听 Context 中的 Dialog 状态\n    useEffect(() => {\n        if (state.createChapterDialogOpen !== showChapterDialog) {\n            setShowChapterDialog(state.createChapterDialogOpen);\n        }\n    }, [state.createChapterDialogOpen]);\n\n    const loadChapters = async () => {\n        try {\n            const resp = await draftsAPI.listChapters(projectId);\n            const list = resp.data || [];\n            setChapters(list);\n        } catch (e) {\n            logger.error('Failed to load chapters:', e);\n        }\n    };\n\n    const handleChapterSelect = async (chapter, presetTitle = '') => {\n        const nextChapterKey = chapter ? String(chapter) : NO_CHAPTER_KEY;\n        const lockedKey = aiLockedChapterRef.current ? String(aiLockedChapterRef.current) : null;\n        const preserveAgent = Boolean(lockedKey) && agentBusy;\n\n        // 缓存当前章节内容，避免切章丢失\n        if (chapterInfo.chapter) {\n            const currentKey = String(chapterInfo.chapter);\n            setManualContentByChapter((prev) => ({ ...(prev || {}), [currentKey]: manualContent }));\n        }\n\n        // 非写作/编辑进行中：切章时清理流式与差异态\n        if (!preserveAgent) {\n            stopStreaming();\n            clearDiffReview();\n            setStatus('editing');\n        } else if (lockedKey && nextChapterKey !== lockedKey) {\n            pushNotice(`正在撰写第 ${lockedKey} 章，AI 面板已锁定；已切换查看第 ${nextChapterKey} 章。`);\n        }\n\n        // Just set the chapter, let SWR handle fetching\n        setChapterInfo({ chapter, chapter_title: presetTitle || '', content: '' }); // content will be filled by SWR\n        setSelectionInfo({ start: 0, end: 0, text: '' });\n        setAttachedSelection(null);\n        setEditScope('document');\n\n        // 优先使用本地缓存，减少切章时的“空白闪烁”\n        if (nextChapterKey && nextChapterKey !== NO_CHAPTER_KEY) {\n            const cached = manualContentByChapterRef.current?.[nextChapterKey];\n            if (typeof cached === 'string') {\n                setManualContent(cached);\n                dispatch({ type: 'SET_WORD_COUNT', payload: countChars(cached) });\n                dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });\n            } else {\n                setManualContent('');\n                dispatch({ type: 'SET_WORD_COUNT', payload: 0 });\n                dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });\n            }\n        }\n        try {\n            const summaryResp = await draftsAPI.getSummary(projectId, chapter);\n            const summary = summaryResp.data || {};\n            const normalizedChapter = summary.chapter || chapter;\n            const title = summary.title || summary.chapter_title || '';\n            setChapterInfo((prev) => ({\n                ...prev,\n                chapter: normalizedChapter,\n                chapter_title: title || prev.chapter_title || ''\n            }));\n            if (normalizedChapter !== chapter) {\n                dispatch({\n                    type: 'SET_ACTIVE_DOCUMENT',\n                    payload: { type: 'chapter', id: normalizedChapter, title: title || presetTitle || '' }\n                });\n            }\n        } catch (e) {\n            // Summary may not exist yet.\n        }\n    };\n\n    const handleChapterCreate = async (chapterData) => {\n        // Handle object from ChapterCreateDialog or direct arguments\n        const chapterNum = typeof chapterData === 'object' ? chapterData.id : chapterData;\n        const chapterTitle = typeof chapterData === 'object' ? chapterData.title : arguments[1];\n\n        // Persist the new chapter immediately\n        setIsSaving(true);\n        let normalizedChapter = chapterNum;\n        try {\n            const resp = await draftsAPI.updateContent(projectId, chapterNum, {\n                content: '',\n                title: chapterTitle\n            });\n            normalizedChapter = resp.data?.chapter || chapterNum;\n            addMessage('system', `已创建章节：${normalizedChapter}`, normalizedChapter);\n            dispatch({\n                type: 'SET_ACTIVE_DOCUMENT',\n                payload: { type: 'chapter', id: normalizedChapter, title: chapterTitle || '' }\n            });\n        } catch (e) {\n            addMessage('error', '创建章节失败: ' + e.message);\n        } finally {\n            setIsSaving(false);\n        }\n\n        setChapterInfo({ chapter: normalizedChapter, chapter_title: chapterTitle, content: '' });\n        setManualContent('');\n        stopStreaming();\n        clearDiffReview();\n        setShowChapterDialog(false);\n        setStatus('idle');\n        await loadChapters();\n    };\n\n    const addMessage = useCallback((type, content, chapterOverride = null) => {\n        const key = chapterOverride ? String(chapterOverride) : activeChapterKey;\n        if (!key || key === NO_CHAPTER_KEY) {\n            return;\n        }\n        setMessagesByChapter((prev) => {\n            const next = { ...(prev || {}) };\n            const existing = Array.isArray(next[key]) ? next[key] : [];\n            next[key] = [...existing, { type, content, time: new Date() }].slice(-200);\n            return next;\n        });\n    }, [activeChapterKey, NO_CHAPTER_KEY]);\n\n    const appendProgressEvent = useCallback((partial, chapterOverride = null) => {\n        const key = chapterOverride ? String(chapterOverride) : activeChapterKey;\n        if (!key || key === NO_CHAPTER_KEY) {\n            return;\n        }\n        const event = {\n            id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,\n            timestamp: Date.now(),\n            ...partial\n        };\n        setProgressEventsByChapter((prev) => {\n            const next = { ...(prev || {}) };\n            const existing = Array.isArray(next[key]) ? next[key] : [];\n            next[key] = [...existing.slice(-199), event];\n            return next;\n        });\n    }, [activeChapterKey, NO_CHAPTER_KEY]);\n\n    // Auto Save（类似 VSCode：检测到变更后自动保存）\n    const autosaveTimerRef = useRef(null);\n    const autosaveInFlightRef = useRef(false);\n    const autosaveLastPayloadRef = useRef({ chapter: null, content: null, title: null });\n\n    useEffect(() => {\n        if (!state.unsavedChanges) return;\n        if (!projectId || !chapterInfo.chapter) return;\n        if (isStreamingForActiveChapter || lockedOnActiveChapter || isDiffReviewForActiveChapter) return;\n\n        const nextContent = String(manualContent || '');\n        const nextTitle = String(chapterInfo.chapter_title || '').trim() || null;\n\n        const last = autosaveLastPayloadRef.current || {};\n        const sameChapter = String(last.chapter || '') === String(chapterInfo.chapter);\n        const sameContent = sameChapter && String(last.content || '') === nextContent;\n        const sameTitle = sameChapter && (last.title || null) === nextTitle;\n        if (sameContent && sameTitle) return;\n\n        if (autosaveTimerRef.current) {\n            window.clearTimeout(autosaveTimerRef.current);\n        }\n\n        autosaveTimerRef.current = window.setTimeout(async () => {\n            if (autosaveInFlightRef.current) return;\n            autosaveInFlightRef.current = true;\n            try {\n                const payload = { content: nextContent };\n                if (nextTitle) payload.title = nextTitle;\n\n                const resp = await draftsAPI.autosaveContent(projectId, chapterInfo.chapter, payload);\n                if (resp.data?.success) {\n                    autosaveLastPayloadRef.current = { chapter: chapterInfo.chapter, content: nextContent, title: nextTitle };\n                    await mutateChapter(nextContent, false);\n                    dispatch({ type: 'SET_AUTOSAVED' });\n                }\n            } catch (e) {\n                dispatch({ type: 'SET_UNSAVED' });\n                addMessage('error', '自动保存失败: ' + (e.response?.data?.detail || e.message));\n            } finally {\n                autosaveInFlightRef.current = false;\n            }\n        }, 1200);\n\n        return () => {\n            if (autosaveTimerRef.current) {\n                window.clearTimeout(autosaveTimerRef.current);\n                autosaveTimerRef.current = null;\n            }\n        };\n    }, [\n        state.unsavedChanges,\n        projectId,\n        chapterInfo.chapter,\n        chapterInfo.chapter_title,\n        manualContent,\n        isStreamingForActiveChapter,\n        lockedOnActiveChapter,\n        isDiffReviewForActiveChapter,\n        mutateChapter,\n        dispatch,\n        addMessage,\n    ]);\n\n    const clearDiffReview = useCallback(() => {\n        setDiffReview(null);\n        setDiffDecisions({});\n    }, []);\n\n    const stopStreaming = useCallback(() => {\n        if (streamingRef.current?.timer) {\n            streamingRef.current.timer();\n        }\n        streamingRef.current = null;\n        setStreamingState({\n            active: false,\n            progress: 0,\n            current: 0,\n            total: 0\n        });\n    }, []);\n\n    // 当资源管理器清空/删除当前章节时，主动回到空态，避免编辑区残留旧章节内容\n    useEffect(() => {\n        if (state.activeDocument) return;\n        stopStreaming();\n        clearDiffReview();\n        setActiveCard(null);\n        setChapterInfo({ chapter: null, chapter_title: null, content: null });\n        setManualContent('');\n        setStatus('idle');\n    }, [clearDiffReview, state.activeDocument, stopStreaming]);\n\n    const startStreamingDraft = useCallback((targetText, options = {}) => {\n        const { onComplete, chapterKey } = options;\n        const resolvedChapterKey = chapterKey ? String(chapterKey) : activeChapterKeyRef.current;\n        stopStreaming();\n        streamingChapterKeyRef.current = resolvedChapterKey;\n\n        const safeText = targetText || '';\n        if (!safeText) {\n            setManualContentByChapter((prev) => ({ ...(prev || {}), [resolvedChapterKey]: '' }));\n            if (activeChapterKeyRef.current === resolvedChapterKey) {\n                setManualContent('');\n            }\n            setIsGenerating(false);\n            streamingChapterKeyRef.current = null;\n            onComplete?.();\n            return;\n        }\n\n        dispatch({ type: 'SET_UNSAVED' });\n        setIsGenerating(true);\n        const total = safeText.length;\n        const charsPerSecond = Math.min(420, Math.max(180, Math.round(total / 3)));\n        let index = 0;\n        let lastTs = performance.now();\n        let rafId = null;\n\n        setManualContentByChapter((prev) => ({ ...(prev || {}), [resolvedChapterKey]: '' }));\n        if (activeChapterKeyRef.current === resolvedChapterKey) {\n            setManualContent('');\n        }\n        setStreamingState({\n            active: true,\n            progress: 0,\n            current: 0,\n            total\n        });\n        lastGeneratedByChapterRef.current[resolvedChapterKey] = true;\n\n        const initialBurst = Math.min(total, Math.max(12, Math.floor(total * 0.03)));\n        if (initialBurst > 0) {\n            index = initialBurst;\n            const burstText = safeText.slice(0, index);\n            setManualContentByChapter((prev) => ({ ...(prev || {}), [resolvedChapterKey]: burstText }));\n            if (activeChapterKeyRef.current === resolvedChapterKey) {\n                setManualContent(burstText);\n            }\n            setStreamingState({\n                active: index < total,\n                progress: Math.round((index / total) * 100),\n                current: index,\n                total\n            });\n        }\n\n        const tick = (ts) => {\n            const delta = Math.max(0, ts - lastTs);\n            const increment = Math.max(1, Math.floor((delta / 1000) * charsPerSecond));\n            index = Math.min(total, index + increment);\n            lastTs = ts;\n\n            const partial = safeText.slice(0, index);\n            setManualContentByChapter((prev) => ({ ...(prev || {}), [resolvedChapterKey]: partial }));\n            if (activeChapterKeyRef.current === resolvedChapterKey) {\n                setManualContent(partial);\n            }\n            setStreamingState({\n                active: index < total,\n                progress: Math.round((index / total) * 100),\n                current: index,\n                total\n            });\n\n            if (index >= total) {\n                streamingRef.current = null;\n                setIsGenerating(false);\n                streamingChapterKeyRef.current = null;\n                if (activeChapterKeyRef.current === resolvedChapterKey) {\n                    dispatch({ type: 'SET_WORD_COUNT', payload: countChars(safeText) });\n                    dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });\n                } else {\n                    pushNotice(`第 ${resolvedChapterKey} 章撰写完成，可切换查看。`);\n                }\n                onComplete?.();\n                return;\n            }\n\n            rafId = window.requestAnimationFrame(tick);\n        };\n\n        rafId = window.requestAnimationFrame(tick);\n        streamingRef.current = {\n            timer: () => {\n                if (rafId) window.cancelAnimationFrame(rafId);\n            }\n        };\n    }, [dispatch, stopStreaming, pushNotice]);\n\n    useEffect(() => {\n        return () => {\n            stopStreaming();\n        };\n    }, [stopStreaming]);\n\n    // 监听 Context 中的文档选择（章节或卡片）\n    useEffect(() => {\n        if (!state.activeDocument) return;\n\n        if (state.activeDocument.type === 'chapter' && state.activeDocument.id) {\n            setActiveCard(null); // Clear card state\n            const presetTitle =\n                state.activeDocument.data?.title ||\n                state.activeDocument.data?.chapter_title ||\n                state.activeDocument.title ||\n                state.activeDocument.chapter_title ||\n                '';\n            handleChapterSelect(state.activeDocument.id, presetTitle);\n        } else if (['character', 'world'].includes(state.activeDocument.type)) {\n            // Switch to Card Mode\n            stopStreaming();\n            clearDiffReview();\n            setChapterInfo({ chapter: null, chapter_title: null, content: null });\n\n            // Initial setup with basic info\n            const cardData = state.activeDocument.data || { name: state.activeDocument.id };\n            const originalName = state.activeDocument.id || cardData.name || '';\n            const isNew = Boolean(state.activeDocument.isNew || cardData.isNew || !originalName);\n            setActiveCard({\n                ...cardData,\n                type: state.activeDocument.type,\n                isNew,\n                originalName\n            });\n            setCardForm({\n                name: cardData.name || '',\n                description: '',\n                aliases: formatListInput(cardData.aliases),\n                stars: normalizeStars(cardData.stars),\n                category: cardData.category || '',\n                rules: formatRulesInput(cardData.rules),\n                immutable: cardData.immutable === true ? 'true' : cardData.immutable === false ? 'false' : 'unset'\n            });\n            setStatus('card_editing');\n\n            // Fetch full details\n            const fetchCardDetails = async () => {\n                try {\n                    let resp;\n                    if (state.activeDocument.type === 'character') {\n                        resp = await cardsAPI.getCharacter(projectId, state.activeDocument.id);\n                    } else {\n                        resp = await cardsAPI.getWorld(projectId, state.activeDocument.id);\n                    }\n                    const fullData = resp?.data || {};\n                    setCardForm({\n                        name: fullData.name || cardData.name || '',\n                        description: fullData.description || '',\n                        aliases: formatListInput(fullData.aliases),\n                        stars: normalizeStars(fullData.stars),\n                        category: fullData.category || '',\n                        rules: formatRulesInput(fullData.rules),\n                        immutable: fullData.immutable === true ? 'true' : fullData.immutable === false ? 'false' : 'unset'\n                    });\n                } catch (e) {\n                    logger.error(\"Failed to fetch card details\", e);\n                    addMessage('error', '加载卡片详情失败: ' + e.message);\n                }\n            };\n\n            if (state.activeDocument.id) {\n                fetchCardDetails();\n            }\n        }\n    }, [state.activeDocument, stopStreaming, clearDiffReview, projectId]);\n\n    // Handlers\n    const handleStart = async (chapter, mode, instruction = null) => {\n        if (!chapter) {\n            alert('请先选择章节');\n            return;\n        }\n        const chapterKey = String(chapter);\n        setAiLockedChapter(chapterKey);\n        setManualContentByChapter((prev) => {\n            const next = { ...(prev || {}) };\n            if (next[chapterKey] === undefined) {\n                next[chapterKey] = manualContent;\n            }\n            return next;\n        });\n\n        stopStreaming();\n        clearDiffReview();\n        serverStreamActiveRef.current = false;\n        serverStreamUsedRef.current = false;\n        setStatus('starting');\n        setIsGenerating(true);\n        setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: null }));\n        setProgressEventsByChapter((prev) => ({ ...(prev || {}), [chapterKey]: [] }));\n\n        setAgentMode('create');\n        appendProgressEvent({ stage: 'session_start', message: '正在准备上下文…' }, chapterKey);\n\n        try {\n            const payload = {\n                chapter: String(chapter),\n                chapter_title: chapterInfo.chapter_title || `章节 ${chapter}`,\n                chapter_goal: instruction || 'Auto-generation based on context',\n                target_word_count: 3000\n            };\n\n            const resp = await sessionAPI.start(projectId, payload);\n            const result = resp.data;\n\n            if (!result.success) {\n                throw new Error(result.error || '会话启动失败');\n            }\n            if (result.status === 'waiting_user_input' && result.questions?.length) {\n                if (result.scene_brief) {\n                    setSceneBrief(result.scene_brief);\n                    appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: result.scene_brief }, chapterKey);\n                }\n                setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: result.context_debug || null }));\n                setPreWriteQuestions(result.questions);\n                setPendingStartPayload(payload);\n                setShowPreWriteDialog(true);\n                setStatus('waiting_user_input');\n                setIsGenerating(false);\n                return;\n            }\n\n            if (result.scene_brief) {\n                setSceneBrief(result.scene_brief);\n                appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: result.scene_brief }, chapterKey);\n            }\n            setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: result.context_debug || null }));\n\n            if (result.draft_v1) {\n                setDraftV1(result.draft_v1);\n            }\n\n            const finalDraft = result.draft_v2 || result.draft_v1;\n            const shouldUseHttpDraft = !serverStreamActiveRef.current && !serverStreamUsedRef.current;\n            if (finalDraft && shouldUseHttpDraft) {\n                setCurrentDraft(finalDraft);\n                setCurrentDraftVersion(result.draft_v2 ? 'v2' : 'v1');\n                startStreamingDraft(finalDraft.content || '', { chapterKey });\n            } else if (shouldUseHttpDraft) {\n                setIsGenerating(false);\n            }\n\n            if (result.proposals) {\n                setProposals(result.proposals);\n            }\n\n            setStatus('waiting_feedback');\n            if (!serverStreamActiveRef.current && !serverStreamUsedRef.current) {\n                addMessage('assistant', '草稿已生成，可继续反馈或手动编辑。', chapterKey);\n            }\n        } catch (e) {\n            addMessage('error', '启动失败: ' + e.message, chapterKey);\n            setStatus('idle');\n            setIsGenerating(false);\n        }\n    };\n\n    const handlePreWriteConfirm = async (answers) => {\n        if (!pendingStartPayload) return;\n        const startPayload = pendingStartPayload;\n        const chapterKey = startPayload?.chapter ? String(startPayload.chapter) : activeChapterKey;\n        if (chapterKey && chapterKey !== NO_CHAPTER_KEY) {\n            setAiLockedChapter(chapterKey);\n        }\n        setShowPreWriteDialog(false);\n        stopStreaming();\n        clearDiffReview();\n        serverStreamActiveRef.current = false;\n        serverStreamUsedRef.current = false;\n        setIsGenerating(true);\n\n        try {\n            const resp = await sessionAPI.answerQuestions(projectId, {\n                ...startPayload,\n                answers\n            });\n            const result = resp.data;\n\n            if (!result.success) {\n                throw new Error(result.error || '回答问题失败');\n            }\n\n            if (result.status === 'waiting_user_input' && result.questions?.length) {\n                setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: result.context_debug || null }));\n                if (result.scene_brief) {\n                    setSceneBrief(result.scene_brief);\n                    appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: result.scene_brief }, chapterKey);\n                }\n                setPreWriteQuestions(result.questions);\n                setPendingStartPayload(startPayload);\n                setShowPreWriteDialog(true);\n                setStatus('waiting_user_input');\n                setIsGenerating(false);\n                return;\n            }\n\n            if (result.scene_brief) {\n                setSceneBrief(result.scene_brief);\n                appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: result.scene_brief }, chapterKey);\n            }\n            setContextDebugByChapter((prev) => ({ ...(prev || {}), [chapterKey]: result.context_debug || null }));\n            if (result.draft_v1) {\n                setDraftV1(result.draft_v1);\n            }\n\n            const finalDraft = result.draft_v2 || result.draft_v1;\n            const shouldUseHttpDraft = !serverStreamActiveRef.current && !serverStreamUsedRef.current;\n            if (finalDraft && shouldUseHttpDraft) {\n                setCurrentDraft(finalDraft);\n                setCurrentDraftVersion(result.draft_v2 ? 'v2' : 'v1');\n                startStreamingDraft(finalDraft.content || '', { chapterKey });\n            } else if (shouldUseHttpDraft) {\n                setIsGenerating(false);\n            }\n\n            if (result.proposals) {\n                setProposals(result.proposals);\n            }\n\n            setStatus('waiting_feedback');\n            if (!serverStreamActiveRef.current && !serverStreamUsedRef.current) {\n                addMessage('assistant', '草稿已生成，可继续反馈或手动编辑。', chapterKey);\n            }\n            setPendingStartPayload(null);\n        } catch (e) {\n            addMessage('error', '生成失败: ' + e.message, chapterKey);\n            setStatus('idle');\n            setIsGenerating(false);\n        }\n    };\n\n    const handlePreWriteSkip = () => {\n        handlePreWriteConfirm([]);\n    };\n\n    const handleSceneBrief = (data, chapterOverride = null) => {\n        setSceneBrief(data);\n        appendProgressEvent({ stage: 'scene_brief', message: '场景简报已生成（可展开查看）', payload: data }, chapterOverride);\n    };\n\n    const handleDraftV1 = (data, chapterOverride = null) => {\n        if (serverStreamActiveRef.current || serverStreamUsedRef.current) {\n            return;\n        }\n        setDraftV1(data);\n        clearDiffReview();\n        const chapterKey = chapterOverride ? String(chapterOverride) : activeChapterKeyRef.current;\n        if (chapterKey && chapterKey !== NO_CHAPTER_KEY) {\n            setAiLockedChapter(chapterKey);\n        }\n        startStreamingDraft(data.content || '', {\n            chapterKey,\n        });\n        setStatus('waiting_feedback');\n        addMessage('assistant', '草稿已生成，可继续反馈或手动编辑。', chapterOverride);\n    };\n\n    const handleFinalDraft = (data, chapterOverride = null) => {\n        if (serverStreamActiveRef.current || serverStreamUsedRef.current) {\n            return;\n        }\n        setCurrentDraft(data);\n        clearDiffReview();\n        const chapterKey = chapterOverride ? String(chapterOverride) : activeChapterKeyRef.current;\n        if (chapterKey && chapterKey !== NO_CHAPTER_KEY) {\n            setAiLockedChapter(chapterKey);\n        }\n        startStreamingDraft(data.content || '', {\n            chapterKey,\n        });\n        setStatus('completed');\n        addMessage('assistant', '终稿已完成。', chapterOverride);\n    };\n\n    const handleSubmitFeedback = async (feedbackOverride) => {\n        const textToSubmit = typeof feedbackOverride === 'string' ? feedbackOverride : feedback;\n        if (!textToSubmit?.trim()) return;\n\n        try {\n            const normalizeLineEndings = (text) => String(text || '').replace(/\\r\\n/g, '\\n');\n            const baseContent = normalizeLineEndings(manualContent);\n            const chapterKey = chapterInfo.chapter ? String(chapterInfo.chapter) : activeChapterKey;\n            if (chapterKey && chapterKey !== NO_CHAPTER_KEY) {\n                setAiLockedChapter(chapterKey);\n            }\n            setIsGenerating(true);\n            setStatus('editing');\n\n            setAgentMode('edit');\n\n            stopStreaming();\n            clearDiffReview();\n            lastFeedbackRef.current = textToSubmit;\n\n            addMessage('user', `修改指令：${textToSubmit}`);\n            appendProgressEvent({ stage: 'edit_suggest', message: '正在生成差异修改建议…' });\n            setFeedback('');\n\n            const payload = {\n                chapter: chapterInfo.chapter ? String(chapterInfo.chapter) : null,\n                content: baseContent,\n                instruction: textToSubmit,\n                context_mode: editContextMode,\n            };\n\n            if (editScope === 'selection' && attachedSelection?.text?.trim()) {\n                const baseSelection = attachedSelection?.text?.trim() ? attachedSelection : null;\n                if (baseSelection) {\n                    const selectionText = String(baseSelection.text || '');\n                    const selectionStart = Math.max(0, Math.min(Number(baseSelection.start || 0), baseContent.length));\n                    const selectionEnd = Math.max(0, Math.min(Number(baseSelection.end || 0), baseContent.length));\n                    payload.selection_text = selectionText;\n                    payload.selection_start = Math.min(selectionStart, selectionEnd);\n                    payload.selection_end = Math.max(selectionStart, selectionEnd);\n                }\n            }\n\n            const resp = await sessionAPI.suggestEdit(projectId, payload);\n\n            const result = resp.data;\n            if (result.success) {\n                let nextContent = normalizeLineEndings(result.revised_content);\n                const tailFix = stabilizeRevisionTail(baseContent, nextContent, textToSubmit);\n                if (tailFix.applied) {\n                    nextContent = normalizeLineEndings(tailFix.text);\n                    addMessage('system', '检测到修改建议疑似截断，已自动补齐原文末尾，请检查差异。');\n                }\n\n                const diff = buildLineDiff(baseContent, nextContent, { contextLines: 2 });\n                const hasChanges = Boolean((diff.stats?.additions || 0) + (diff.stats?.deletions || 0));\n\n                if (!hasChanges) {\n                    throw new Error('未能生成可应用的差异修改：请复制粘贴要修改的原句/段落，或使用“选区编辑”进行精确定位。');\n                }\n\n                appendProgressEvent({\n                    stage: 'edit_suggest_done',\n                    message: `差异修改建议已生成（${diff.stats.additions || 0} 新增 / ${diff.stats.deletions || 0} 删除）`\n                });\n\n                const hunksWithReason = (diff.hunks || []).map((hunk) => ({\n                    ...hunk,\n                    reason: lastFeedbackRef.current || '根据用户指令进行调整'\n                }));\n                const initialDecisions = hunksWithReason.reduce((acc, hunk) => {\n                    acc[hunk.id] = 'accepted';\n                    return acc;\n                }, {});\n                setDiffDecisions(initialDecisions);\n                setDiffReview({\n                    ...diff,\n                    hunks: hunksWithReason,\n                    originalContent: baseContent,\n                    revisedContent: nextContent,\n                    chapterKey,\n                });\n                setStatus('waiting_feedback');\n                addMessage('assistant', '已生成差异修改建议：可查看差异并选择“接受”或“撤销”。');\n            } else {\n                throw new Error(result.error || 'Edit failed');\n            }\n\n            setIsGenerating(false);\n        } catch (e) {\n            addMessage('error', '编辑失败: ' + e.message);\n            setIsGenerating(false);\n            setStatus('waiting_feedback');\n        }\n    };\n\n    const handleAcceptAllDiff = () => {\n        if (!diffReview) return;\n        const nextContent = diffReview.revisedContent || '';\n        if ((loadedContent ?? '') !== nextContent) {\n            dispatch({ type: 'SET_UNSAVED' });\n        }\n        setManualContent(nextContent);\n        if (diffReview.chapterKey) {\n            const key = String(diffReview.chapterKey);\n            setManualContentByChapter((prev) => ({ ...(prev || {}), [key]: nextContent }));\n        }\n        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(nextContent) });\n        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });\n        clearDiffReview();\n    };\n\n    const handleRejectAllDiff = () => {\n        if (!diffReview) return;\n        const nextContent = diffReview.originalContent || '';\n        if ((loadedContent ?? '') !== nextContent) {\n            dispatch({ type: 'SET_UNSAVED' });\n        }\n        setManualContent(nextContent);\n        if (diffReview.chapterKey) {\n            const key = String(diffReview.chapterKey);\n            setManualContentByChapter((prev) => ({ ...(prev || {}), [key]: nextContent }));\n        }\n        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(nextContent) });\n        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });\n        clearDiffReview();\n    };\n\n    const handleAcceptDiffHunk = (hunkId) => {\n        setDiffDecisions((prev) => {\n            const next = { ...(prev || {}) };\n            const current = next[hunkId];\n            next[hunkId] = current === 'accepted' ? 'pending' : 'accepted';\n            return next;\n        });\n    };\n\n    const handleRejectDiffHunk = (hunkId) => {\n        setDiffDecisions((prev) => {\n            const next = { ...(prev || {}) };\n            const current = next[hunkId];\n            next[hunkId] = current === 'rejected' ? 'pending' : 'rejected';\n            return next;\n        });\n    };\n\n    const handleApplySelectedDiff = () => {\n        if (!diffReview) return;\n        const originalLines = diffReview.originalLines || (diffReview.originalContent || '').split('\\n');\n        const ops = diffReview.ops || [];\n        const hasDecisions = Object.keys(diffDecisions || {}).length > 0;\n        const nextContent = hasDecisions\n            ? applyDiffOpsWithDecisions(originalLines, ops, diffDecisions)\n            : (diffReview.revisedContent || '');\n        if ((loadedContent ?? '') !== nextContent) {\n            dispatch({ type: 'SET_UNSAVED' });\n        }\n        setManualContent(nextContent);\n        if (diffReview.chapterKey) {\n            const key = String(diffReview.chapterKey);\n            setManualContentByChapter((prev) => ({ ...(prev || {}), [key]: nextContent }));\n        }\n        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(nextContent) });\n        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });\n        clearDiffReview();\n    };\n\n    const saveDraftContent = async () => {\n        if (!chapterInfo.chapter) return { success: false };\n        const trimmedTitle = String(chapterInfo.chapter_title || '').trim();\n        const payload = { content: manualContent };\n        if (trimmedTitle) {\n            payload.title = trimmedTitle;\n        }\n        const resp = await draftsAPI.updateContent(projectId, chapterInfo.chapter, payload);\n        if (resp.data?.success) {\n            const normalizedChapter = resp.data?.chapter || chapterInfo.chapter;\n            if (normalizedChapter && normalizedChapter !== chapterInfo.chapter) {\n                setChapterInfo((prev) => ({ ...prev, chapter: normalizedChapter }));\n                dispatch({ type: 'SET_ACTIVE_DOCUMENT', payload: { type: 'chapter', id: normalizedChapter } });\n                await loadChapters();\n            }\n            if (typeof resp.data?.title === 'string' && resp.data.title.trim()) {\n                setChapterInfo((prev) => ({ ...prev, chapter_title: resp.data.title }));\n            }\n            dispatch({ type: 'SET_SAVED' });\n            mutateChapter(manualContent, false);\n        }\n        return resp.data;\n    };\n\n    const handleManualSave = async () => {\n        if (!chapterInfo.chapter) return;\n        setIsSaving(true);\n        try {\n            const result = await saveDraftContent();\n            if (result?.success) {\n                addMessage('system', '\\u8349\\u7a3f\\u5df2\\u4fdd\\u5b58');\n            }\n        } catch (e) {\n            addMessage('error', '\\u4fdd\\u5b58\\u5931\\u8d25: ' + e.message);\n        } finally {\n            setIsSaving(false);\n        }\n    };\n\n    const handleAnalyzeAndSave = async () => {\n        if (!chapterInfo.chapter) return;\n        setAnalysisLoading(true);\n        try {\n            const saved = await saveDraftContent();\n            if (!saved?.success) {\n                throw new Error(saved?.message || '\\u4fdd\\u5b58\\u5931\\u8d25');\n            }\n            const normalizedChapter = saved?.chapter || chapterInfo.chapter;\n            const resp = await sessionAPI.analyze(projectId, {\n                chapter: normalizedChapter,\n                content: manualContent,\n                chapter_title: chapterInfo.chapter_title || '',\n            });\n            if (resp.data?.success) {\n                setAnalysisItems([{ chapter: normalizedChapter, analysis: resp.data.analysis || {} }]);\n                setAnalysisDialogOpen(true);\n                addMessage('system', '\\u5206\\u6790\\u5b8c\\u6210，\\u8bf7\\u786e\\u8ba4\\u5e76\\u4fdd\\u5b58\\u3002');\n            } else {\n                throw new Error(resp.data?.error || '\\u5206\\u6790\\u5931\\u8d25');\n            }\n        } catch (e) {\n            addMessage('error', '\\u5206\\u6790\\u5931\\u8d25: ' + e.message);\n        } finally {\n            setAnalysisLoading(false);\n        }\n    };\n\n    const handleSaveAnalysis = async (payload) => {\n        setAnalysisSaving(true);\n        try {\n            if (Array.isArray(payload)) {\n                const resp = await sessionAPI.saveAnalysisBatch(projectId, {\n                    items: payload,\n                    overwrite: true,\n                });\n                if (!resp.data?.success) {\n                    throw new Error(resp.data?.error || '\\u5206\\u6790\\u5931\\u8d25');\n                }\n            } else if (chapterInfo.chapter) {\n                const resp = await sessionAPI.saveAnalysis(projectId, {\n                    chapter: chapterInfo.chapter,\n                    analysis: payload,\n                    overwrite: true,\n                });\n                if (!resp.data?.success) {\n                    throw new Error(resp.data?.error || '\\u5206\\u6790\\u5931\\u8d25');\n                }\n            }\n            addMessage('system', '\\u5206\\u6790\\u4fdd\\u5b58\\u5b8c\\u6210');\n            setAnalysisDialogOpen(false);\n            setAnalysisItems([]);\n        } catch (e) {\n            addMessage('error', '\\u4fdd\\u5b58\\u5931\\u8d25: ' + e.message);\n        } finally {\n            setAnalysisSaving(false);\n        }\n    };\n\n    // Phase 4.3: Handle user answer for AskUser\n    // Card Handlers\n    const handleCardSave = async () => {\n        if (!activeCard) return;\n        setIsSaving(true);\n        try {\n            const name = (cardForm.name || '').trim();\n            if (!name) {\n                throw new Error('卡片名称不能为空');\n            }\n            const stars = normalizeStars(cardForm.stars);\n            const aliases = parseListInput(cardForm.aliases);\n            if (activeCard.type === 'character') {\n                const payload = {\n                    name,\n                    description: cardForm.description || '',\n                    aliases,\n                    stars\n                };\n                if (activeCard.isNew || !activeCard.originalName) {\n                    await cardsAPI.createCharacter(projectId, payload);\n                } else if (activeCard.originalName !== name) {\n                    await cardsAPI.createCharacter(projectId, payload);\n                    await cardsAPI.deleteCharacter(projectId, activeCard.originalName);\n                } else {\n                    await cardsAPI.updateCharacter(projectId, activeCard.originalName, payload);\n                }\n            } else {\n                const rules = parseListInput(cardForm.rules);\n                const immutableValue =\n                    cardForm.immutable === 'true' ? true : cardForm.immutable === 'false' ? false : undefined;\n                const payload = {\n                    name,\n                    description: cardForm.description || '',\n                    aliases,\n                    category: (cardForm.category || '').trim(),\n                    rules,\n                    stars\n                };\n                if (immutableValue !== undefined) {\n                    payload.immutable = immutableValue;\n                }\n                if (activeCard.isNew || !activeCard.originalName) {\n                    await cardsAPI.createWorld(projectId, payload);\n                } else if (activeCard.originalName !== name) {\n                    await cardsAPI.createWorld(projectId, payload);\n                    await cardsAPI.deleteWorld(projectId, activeCard.originalName);\n                } else {\n                    await cardsAPI.updateWorld(projectId, activeCard.originalName, payload);\n                }\n            }\n            try {\n                const refreshed = activeCard.type === 'character'\n                    ? await cardsAPI.getCharacter(projectId, name)\n                    : await cardsAPI.getWorld(projectId, name);\n                const refreshedData = refreshed?.data;\n                if (refreshedData?.name) {\n                    setActiveCard({\n                        ...refreshedData,\n                        type: activeCard.type,\n                        isNew: false,\n                        originalName: refreshedData.name,\n                    });\n                    setCardForm({\n                        name: refreshedData.name || '',\n                        description: refreshedData.description || '',\n                        aliases: formatListInput(refreshedData.aliases),\n                        stars: normalizeStars(refreshedData.stars),\n                        category: refreshedData.category || '',\n                        rules: formatRulesInput(refreshedData.rules),\n                        immutable: refreshedData.immutable === true ? 'true' : refreshedData.immutable === false ? 'false' : 'unset'\n                    });\n                }\n            } catch (error) {\n                logger.error('Failed to refresh card data', error);\n            }\n            addMessage('system', '卡片已更新');\n            dispatch({ type: 'SET_SAVED' });\n        } catch (e) {\n            const detail = e?.response?.data?.detail || e?.response?.data?.error;\n            addMessage('error', '卡片保存失败: ' + (detail || e.message));\n        } finally {\n            setIsSaving(false);\n        }\n    };\n\n    const renderMainContent = () => {\n        if (state.activeActivity === 'fanfiction') {\n            return (\n                <FanfictionView\n                    embedded\n                    onClose={() => dispatch({ type: 'SET_ACTIVE_PANEL', payload: 'explorer' })}\n                />\n            );\n        }\n        return (\n            <AnimatePresence mode=\"wait\">\n                {status === 'card_editing' && activeCard ? (\n                    <motion.div\n                        key=\"card-editor\"\n                        initial={{ opacity: 0, scale: 0.98, y: 10 }}\n                        animate={{ opacity: 1, scale: 1, y: 0 }}\n                        exit={{ opacity: 0, scale: 0.98, y: -10 }}\n                        transition={{ duration: 0.3, ease: \"easeOut\" }}\n                        className=\"h-full flex flex-col max-w-3xl mx-auto w-full pt-4\"\n                    >\n                        <div className=\"flex items-center justify-between mb-6 pb-4 border-b border-border\">\n                            <div className=\"flex items-center gap-3\">\n                                <div className=\"p-2 bg-primary/10 rounded-lg text-primary\">\n                                    {activeCard.type === 'character' ? <div className=\"i-lucide-user\" /> : <div className=\"i-lucide-globe\" />}\n                                    {activeCard.type === 'character' ? '👤' : '🌍'}\n                                </div>\n                                <div>\n                                    <p className=\"text-xs text-ink-400 font-mono uppercase tracking-wider\">{activeCard.type === 'character' ? '角色卡片' : '世界卡片'}</p>\n                                </div>\n                            </div>\n                            <button\n                                onClick={() => {\n                                    setStatus('idle');\n                                    setActiveCard(null);\n                                }}\n                                className=\"p-2 hover:bg-ink-100 rounded-lg transition-colors text-ink-400 hover:text-ink-700\"\n                                title=\"关闭卡片编辑\"\n                            >\n                                <X size={20} />\n                            </button>\n                        </div>\n\n                        <div className=\"space-y-6 flex-1 overflow-y-auto px-1 pb-20\">\n                            {/* Common: Name */}\n                            <div className=\"space-y-1\">\n                                <label className=\"text-xs font-bold text-ink-500 tracking-wider\">名称</label>\n                                <Input\n                                    value={cardForm.name}\n                                    onChange={e => setCardForm(prev => ({ ...prev, name: e.target.value }))}\n                                    className=\"font-serif text-lg bg-[var(--vscode-input-bg)] font-bold\"\n                                />\n                            </div>\n\n                            <div className=\"space-y-1\">\n                                <label className=\"text-xs font-bold text-ink-500 tracking-wider\">星级</label>\n                                <select\n                                    value={cardForm.stars}\n                                    onChange={e => setCardForm(prev => ({ ...prev, stars: normalizeStars(e.target.value) }))}\n                                    className=\"w-full h-10 px-3 rounded-[6px] border border-[var(--vscode-input-border)] bg-[var(--vscode-input-bg)] text-sm focus:ring-1 focus:ring-[var(--vscode-focus-border)]\"\n                                >\n                                    <option value={3}>三星（必须关注）</option>\n                                    <option value={2}>二星（重要）</option>\n                                    <option value={1}>一星（可选）</option>\n                                </select>\n                            </div>\n\n                            <div className=\"space-y-1\">\n                                <label className=\"text-xs font-bold text-ink-500 tracking-wider\">别名</label>\n                                <Input\n                                    value={cardForm.aliases || ''}\n                                    onChange={e => setCardForm(prev => ({ ...prev, aliases: e.target.value }))}\n                                    placeholder=\"多个别名用逗号分隔\"\n                                    className=\"bg-[var(--vscode-input-bg)]\"\n                                />\n                            </div>\n\n                            {activeCard.type === 'world' && (\n                                <>\n                                    <div className=\"space-y-1\">\n                                        <label className=\"text-xs font-bold text-ink-500 tracking-wider\">类别</label>\n                                        <Input\n                                            value={cardForm.category || ''}\n                                            onChange={e => setCardForm(prev => ({ ...prev, category: e.target.value }))}\n                                            placeholder=\"世界元素类别\"\n                                            className=\"bg-[var(--vscode-input-bg)]\"\n                                        />\n                                    </div>\n                                    <div className=\"space-y-1\">\n                                        <label className=\"text-xs font-bold text-ink-500 tracking-wider\">规则</label>\n                                        <textarea\n                                            className=\"w-full min-h-[140px] p-3 rounded-[6px] border border-[var(--vscode-input-border)] bg-[var(--vscode-input-bg)] text-sm focus:ring-1 focus:ring-[var(--vscode-focus-border)] resize-none overflow-hidden\"\n                                            value={cardForm.rules || ''}\n                                            onChange={e => {\n                                                setCardForm(prev => ({ ...prev, rules: e.target.value }));\n                                                e.target.style.height = 'auto';\n                                                e.target.style.height = e.target.scrollHeight + 'px';\n                                            }}\n                                            onFocus={e => {\n                                                e.target.style.height = 'auto';\n                                                e.target.style.height = e.target.scrollHeight + 'px';\n                                            }}\n                                            placeholder=\"每行一条规则\"\n                                        />\n                                    </div>\n                                    <div className=\"space-y-1\">\n                                        <label className=\"text-xs font-bold text-ink-500 tracking-wider\">不可变</label>\n                                        <select\n                                            value={cardForm.immutable}\n                                            onChange={e => setCardForm(prev => ({ ...prev, immutable: e.target.value }))}\n                                            className=\"w-full h-10 px-3 rounded-[6px] border border-[var(--vscode-input-border)] bg-[var(--vscode-input-bg)] text-sm focus:ring-1 focus:ring-[var(--vscode-focus-border)]\"\n                                        >\n                                            <option value=\"unset\">未设置</option>\n                                            <option value=\"true\">不可变</option>\n                                            <option value=\"false\">可变</option>\n                                        </select>\n                                    </div>\n                                </>\n                            )}\n\n                            {/* Card Description */}\n                            <div className=\"space-y-1\">\n                                <label className=\"text-xs font-bold text-ink-500 tracking-wider\">描述</label>\n                                <textarea\n                                    className=\"w-full min-h-[200px] p-3 rounded-[6px] border border-[var(--vscode-input-border)] bg-[var(--vscode-input-bg)] text-sm focus:ring-1 focus:ring-[var(--vscode-focus-border)] resize-none overflow-hidden\"\n                                    value={cardForm.description || ''}\n                                    onChange={e => {\n                                        setCardForm(prev => ({ ...prev, description: e.target.value }));\n                                        e.target.style.height = 'auto';\n                                        e.target.style.height = e.target.scrollHeight + 'px';\n                                    }}\n                                    onFocus={e => {\n                                        e.target.style.height = 'auto';\n                                        e.target.style.height = e.target.scrollHeight + 'px';\n                                    }}\n                                    placeholder=\"请简要描述\"\n                                />\n                            </div>\n\n                        </div>\n                    </motion.div>\n                ) : !chapterInfo.chapter ? (\n                    <motion.div\n                        key=\"empty-state\"\n                        initial={{ opacity: 0 }}\n                        animate={{ opacity: 1 }}\n                        exit={{ opacity: 0 }}\n                        className=\"h-[60vh] flex items-center justify-center\"\n                    >\n                        <div className=\"text-center\">\n                            <div className=\"flex flex-col items-center gap-2 mb-4\">\n                                <span className=\"brand-logo text-4xl text-ink-900/40\">文枢</span>\n                            </div>\n                            <p className=\"text-sm text-ink-500\">\n                                请在左侧选择资源，或使用快捷键 Cmd+B 切换面板\n                            </p>\n                        </div>\n                    </motion.div>\n                ) : (\n                    <motion.div\n                        key=\"chapter-editor\"\n                        initial={{ opacity: 0, y: 10 }}\n                        animate={{ opacity: 1, y: 0 }}\n                        exit={{ opacity: 0, y: -10 }}\n                        transition={{ duration: 0.3 }}\n                        className=\"h-full flex flex-col relative\"\n                    >\n                        <div className=\"mb-4 pb-3 border-b border-border flex flex-wrap items-center gap-3\">\n                            <span className=\"text-[11px] font-mono text-ink-500 uppercase tracking-wider\">{chapterInfo.chapter}</span>\n                            <input\n                                className=\"flex-1 min-w-[200px] bg-transparent text-2xl font-serif font-bold text-ink-900 outline-none placeholder:text-ink-300\"\n                                value={chapterInfo.chapter_title || ''}\n                                onChange={(e) => {\n                                    setChapterInfo((prev) => ({ ...prev, chapter_title: e.target.value }));\n                                    dispatch({ type: 'SET_UNSAVED' });\n                                }}\n                                placeholder=\"请输入章节标题\"\n                                disabled={!chapterInfo.chapter}\n                            />\n                        </div>\n                        <div className=\"flex-1 overflow-hidden bg-[var(--vscode-bg)] border-t border-[var(--vscode-sidebar-border)]\">\n                            {isDiffReviewForActiveChapter ? (\n                                <DiffReviewView\n                                    ops={diffReview.ops}\n                                    hunks={diffReview.hunks}\n                                    stats={diffReview.stats}\n                                    decisions={diffDecisions}\n                                    onAcceptHunk={handleAcceptDiffHunk}\n                                    onRejectHunk={handleRejectDiffHunk}\n                                    originalVersion=\"当前正文\"\n                                    revisedVersion=\"修改建议\"\n                                />\n                            ) : isStreamingForActiveChapter ? (\n                                <StreamingDraftView\n                                    content={manualContent}\n                                    active={isStreamingForActiveChapter}\n                                    className=\"h-full\"\n                                />\n                            ) : (\n                                <textarea\n                                    className=\"h-full w-full resize-none border-none outline-none bg-transparent p-6 text-base font-serif text-ink-900 leading-relaxed focus:ring-0 placeholder:text-ink-300 overflow-y-auto editor-scrollbar\"\n                                    value={manualContent}\n                                    onChange={(e) => {\n                                        const nextValue = e.target.value;\n                                        setManualContent(nextValue);\n                                        if (chapterInfo.chapter) {\n                                            const key = String(chapterInfo.chapter);\n                                            setManualContentByChapter((prev) => ({ ...(prev || {}), [key]: nextValue }));\n                                        }\n                                        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(nextValue) });\n                                        const stats = getSelectionStats(nextValue, e.target.selectionStart, e.target.selectionEnd);\n                                        dispatch({ type: 'SET_SELECTION_COUNT', payload: stats.selectionCount });\n                                        setSelectionInfo({\n                                            start: stats.selectionStart,\n                                            end: stats.selectionEnd,\n                                            text: stats.selectionText || '',\n                                        });\n                                        const lines = stats.cursorText.split('\\n');\n                                        dispatch({\n                                            type: 'SET_CURSOR_POSITION',\n                                            payload: {\n                                                line: lines.length,\n                                                column: lines[lines.length - 1].length + 1\n                                            }\n                                        });\n                                        dispatch({ type: 'SET_UNSAVED' });\n                                    }}\n                                    onSelect={(e) => {\n                                        const stats = getSelectionStats(e.target.value, e.target.selectionStart, e.target.selectionEnd);\n                                        dispatch({ type: 'SET_SELECTION_COUNT', payload: stats.selectionCount });\n                                        setSelectionInfo({\n                                            start: stats.selectionStart,\n                                            end: stats.selectionEnd,\n                                            text: stats.selectionText || '',\n                                        });\n                                        const lines = stats.cursorText.split('\\n');\n                                        dispatch({\n                                            type: 'SET_CURSOR_POSITION',\n                                            payload: {\n                                                line: lines.length,\n                                                column: lines[lines.length - 1].length + 1\n                                            }\n                                        });\n                                    }}\n                                    placeholder=\"开始写作...\"\n                                    disabled={!chapterInfo.chapter || lockedOnActiveChapter}\n                                    spellCheck={false}\n                                />\n                            )}\n                        </div>\n\n                    </motion.div>\n                )}\n            </AnimatePresence>\n        );\n    };\n\n    const rightPanelContent = (\n        <AgentsPanel traceEvents={traceEvents} agentTraces={agentTraces}>\n            <AgentStatusPanel\n                mode={agentMode}\n                onModeChange={setAgentMode}\n                createDisabled={!canUseWriter}\n                inputDisabled={agentBusy && String(aiLockedChapter || '') !== activeChapterKey}\n                inputDisabledReason={\n                    agentBusy && String(aiLockedChapter || '') !== activeChapterKey\n                        ? `AI 正在撰写第 ${String(aiLockedChapter)} 章：右侧对话已锁定，请切换回该章节继续。`\n                        : ''\n                }\n                selectionCandidateSummary={\n                    agentMode === 'edit' && selectionInfo?.text?.trim()\n                        ? `已选中 ${countChars(selectionInfo.text)} 字（未添加）`\n                        : ''\n                }\n                selectionAttachedSummary={\n                    agentMode === 'edit' && attachedSelection?.text?.trim()\n                        ? `已添加选区 ${countChars(attachedSelection.text)} 字`\n                        : ''\n                }\n                selectionCandidateDifferent={\n                    Boolean(selectionInfo?.text?.trim()) &&\n                    Boolean(attachedSelection?.text?.trim()) &&\n                    (selectionInfo.start !== attachedSelection.start ||\n                        selectionInfo.end !== attachedSelection.end ||\n                        selectionInfo.text !== attachedSelection.text)\n                }\n                onAttachSelection={() => {\n                    if (!selectionInfo?.text?.trim()) return;\n                    setAttachedSelection({\n                        start: selectionInfo.start,\n                        end: selectionInfo.end,\n                        text: selectionInfo.text,\n                    });\n                    setEditScope('selection');\n                }}\n                onClearAttachedSelection={() => {\n                    setAttachedSelection(null);\n                    setEditScope('document');\n                }}\n                editScope={editScope}\n                onEditScopeChange={setEditScope}\n                contextDebug={contextDebug}\n                progressEvents={progressEvents}\n                messages={messages}\n                memoryPackStatus={memoryPackStatus}\n                activeChapter={agentBusy ? aiLockedChapter : chapterInfo.chapter}\n                editContextMode={editContextMode}\n                onEditContextModeChange={setEditContextMode}\n                diffReview={diffReview && String(diffReview?.chapterKey || '') === agentChapterKey ? diffReview : null}\n                diffDecisions={diffDecisions}\n                onAcceptAllDiff={handleAcceptAllDiff}\n                onRejectAllDiff={handleRejectAllDiff}\n                onApplySelectedDiff={handleApplySelectedDiff}\n                onSubmit={(text) => {\n                    if (!chapterInfo.chapter) {\n                        addMessage('system', '请先选择章节。');\n                        return;\n                    }\n\n                    if (agentMode === 'create') {\n                        if (!canUseWriter) {\n                            addMessage('system', '正文非空：主笔仅在正文为空时可用，请切换到编辑模式。');\n                            setAgentMode('edit');\n                            return;\n                        }\n                        addMessage('user', text);\n                        handleStart(chapterInfo.chapter, 'deep', text);\n                        return;\n                    }\n\n                    handleSubmitFeedback(text);\n                }}\n            />\n        </AgentsPanel>\n    );\n\n\n    \n    const saveBusy = isSaving || analysisLoading || analysisSaving;\n    const showSaveAction = (chapterInfo.chapter || status === 'card_editing') && !lockedOnActiveChapter;\n    const saveAction = showSaveAction ? (\n        status === 'card_editing' ? (\n            <Button\n                onClick={handleCardSave}\n                disabled={isSaving}\n                className=\"shadow-sm\"\n                size=\"sm\"\n            >\n                {isSaving ? '\\u4fdd\\u5b58\\u4e2d...' : '\\u4fdd\\u5b58'}\n            </Button>\n        ) : (\n            <SaveMenu\n                disabled={!chapterInfo.chapter || saveBusy}\n                busy={saveBusy}\n                onSaveOnly={handleManualSave}\n                onAnalyzeSave={handleAnalyzeAndSave}\n            />\n        )\n    ) : null;\n\n    const titleBarProps = {\n        projectName: project?.name,\n        rightActions: saveAction,\n        // Show Card Name in Title if card editing\n        chapterTitle: status === 'card_editing'\n            ? cardForm.name\n            : (chapterInfo.chapter ? (chapterInfo.chapter_title || `章节 ${chapterInfo.chapter}`) : null),\n        aiHint: agentBusy && aiLockedChapter ? `正在撰写第 ${String(aiLockedChapter)} 章` : null,\n    };\n\n    return (\n        <IDELayout rightPanelContent={rightPanelContent} titleBarProps={titleBarProps}>\n            <div className=\"w-full h-full px-8 py-6\">\n                {renderMainContent()}\n            </div>\n\n            {notice ? (\n                <div\n                    key={notice.id}\n                    className=\"fixed bottom-4 right-4 z-[60] max-w-[420px] rounded-[6px] border border-[var(--vscode-sidebar-border)] bg-[var(--vscode-input-bg)] px-3 py-2 text-xs text-[var(--vscode-fg)] shadow-md\"\n                >\n                    {notice.text}\n                </div>\n            ) : null}\n\n\n            <ChapterCreateDialog\n                open={showChapterDialog}\n                onClose={() => {\n                    setShowChapterDialog(false);\n                    dispatch({ type: 'CLOSE_CREATE_CHAPTER_DIALOG' });\n                }}\n                onConfirm={handleChapterCreate}\n                existingChapters={chapters.map(c => ({ id: c, title: '' }))}\n                volumes={volumes}\n                defaultVolumeId={state.selectedVolumeId || 'V1'}\n            />\n\n            <PreWritingQuestionsDialog\n                open={showPreWriteDialog}\n                questions={preWriteQuestions}\n                onConfirm={handlePreWriteConfirm}\n                onSkip={handlePreWriteSkip}\n            />\n\n            <AnalysisReviewDialog\n                open={analysisDialogOpen}\n                analyses={analysisItems}\n                onCancel={() => {\n                    setAnalysisDialogOpen(false);\n                    setAnalysisItems([]);\n                }}\n                onSave={handleSaveAnalysis}\n                saving={analysisSaving}\n            />\n\n        </IDELayout >\n    );\n}\n\n/**\n * WritingSession - 写作会话入口\n * 提供 IDE 上下文并渲染主容器。\n */\nexport default function WritingSession(props) {\n    const { projectId } = useParams();\n    return (\n        <IDEProvider projectId={projectId}>\n            <WritingSessionContent {...props} />\n        </IDEProvider>\n    );\n}\n"}