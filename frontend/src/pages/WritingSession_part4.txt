            };

            if (editScope === 'selection' && attachedSelection?.text?.trim()) {
                const baseSelection = attachedSelection?.text?.trim() ? attachedSelection : null;
                if (baseSelection) {
                    const selectionText = String(baseSelection.text || '');
                    const selectionStart = Math.max(0, Math.min(Number(baseSelection.start || 0), baseContent.length));
                    const selectionEnd = Math.max(0, Math.min(Number(baseSelection.end || 0), baseContent.length));
                    payload.selection_text = selectionText;
                    payload.selection_start = Math.min(selectionStart, selectionEnd);
                    payload.selection_end = Math.max(selectionStart, selectionEnd);
                }
            }

            const resp = await sessionAPI.suggestEdit(projectId, payload);

            const result = resp.data;
            if (result.success) {
                let nextContent = normalizeLineEndings(result.revised_content);
                const tailFix = stabilizeRevisionTail(baseContent, nextContent, textToSubmit);
                if (tailFix.applied) {
                    nextContent = normalizeLineEndings(tailFix.text);
                    addMessage('system', 'æ£€æµ‹åˆ°ä¿®æ”¹å»ºè®®ç–‘ä¼¼æˆªæ–­ï¼Œå·²è‡ªåŠ¨è¡¥é½åŸæ–‡æœ«å°¾ï¼Œè¯·æ£€æŸ¥å·®å¼‚ã€‚');
                }

                const diff = buildLineDiff(baseContent, nextContent, { contextLines: 2 });
                const hasChanges = Boolean((diff.stats?.additions || 0) + (diff.stats?.deletions || 0));

                if (!hasChanges) {
                    throw new Error('æœªèƒ½ç”Ÿæˆå¯åº”ç”¨çš„å·®å¼‚ä¿®æ”¹ï¼šè¯·å¤åˆ¶ç²˜è´´è¦ä¿®æ”¹çš„åŸå¥/æ®µè½ï¼Œæˆ–ä½¿ç”¨â€œé€‰åŒºç¼–è¾‘â€è¿›è¡Œç²¾ç¡®å®šä½ã€‚');
                }

                appendProgressEvent({
                    stage: 'edit_suggest_done',
                    message: `å·®å¼‚ä¿®æ”¹å»ºè®®å·²ç”Ÿæˆï¼ˆ${diff.stats.additions || 0} æ–°å¢ / ${diff.stats.deletions || 0} åˆ é™¤ï¼‰`
                });

                const hunksWithReason = (diff.hunks || []).map((hunk) => ({
                    ...hunk,
                    reason: lastFeedbackRef.current || 'æ ¹æ®ç”¨æˆ·æŒ‡ä»¤è¿›è¡Œè°ƒæ•´'
                }));
                const initialDecisions = hunksWithReason.reduce((acc, hunk) => {
                    acc[hunk.id] = 'accepted';
                    return acc;
                }, {});
                setDiffDecisions(initialDecisions);
                setDiffReview({
                    ...diff,
                    hunks: hunksWithReason,
                    originalContent: baseContent,
                    revisedContent: nextContent,
                    chapterKey,
                });
                setStatus('waiting_feedback');
                addMessage('assistant', 'å·²ç”Ÿæˆå·®å¼‚ä¿®æ”¹å»ºè®®ï¼šå¯æŸ¥çœ‹å·®å¼‚å¹¶é€‰æ‹©â€œæ¥å—â€æˆ–â€œæ’¤é”€â€ã€‚');
            } else {
                throw new Error(result.error || 'Edit failed');
            }

            setIsGenerating(false);
        } catch (e) {
            addMessage('error', 'ç¼–è¾‘å¤±è´¥: ' + e.message);
            setIsGenerating(false);
            setStatus('waiting_feedback');
        }
    };

    const handleAcceptAllDiff = () => {
        if (!diffReview) return;
        const nextContent = diffReview.revisedContent || '';
        if ((loadedContent ?? '') !== nextContent) {
            dispatch({ type: 'SET_UNSAVED' });
        }
        setManualContent(nextContent);
        if (diffReview.chapterKey) {
            const key = String(diffReview.chapterKey);
            setManualContentByChapter((prev) => ({ ...(prev || {}), [key]: nextContent }));
        }
        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(nextContent) });
        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });
        clearDiffReview();
    };

    const handleRejectAllDiff = () => {
        if (!diffReview) return;
        const nextContent = diffReview.originalContent || '';
        if ((loadedContent ?? '') !== nextContent) {
            dispatch({ type: 'SET_UNSAVED' });
        }
        setManualContent(nextContent);
        if (diffReview.chapterKey) {
            const key = String(diffReview.chapterKey);
            setManualContentByChapter((prev) => ({ ...(prev || {}), [key]: nextContent }));
        }
        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(nextContent) });
        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });
        clearDiffReview();
    };

    const handleAcceptDiffHunk = (hunkId) => {
        setDiffDecisions((prev) => {
            const next = { ...(prev || {}) };
            const current = next[hunkId];
            next[hunkId] = current === 'accepted' ? 'pending' : 'accepted';
            return next;
        });
    };

    const handleRejectDiffHunk = (hunkId) => {
        setDiffDecisions((prev) => {
            const next = { ...(prev || {}) };
            const current = next[hunkId];
            next[hunkId] = current === 'rejected' ? 'pending' : 'rejected';
            return next;
        });
    };

    const handleApplySelectedDiff = () => {
        if (!diffReview) return;
        const originalLines = diffReview.originalLines || (diffReview.originalContent || '').split('\n');
        const ops = diffReview.ops || [];
        const hasDecisions = Object.keys(diffDecisions || {}).length > 0;
        const nextContent = hasDecisions
            ? applyDiffOpsWithDecisions(originalLines, ops, diffDecisions)
            : (diffReview.revisedContent || '');
        if ((loadedContent ?? '') !== nextContent) {
            dispatch({ type: 'SET_UNSAVED' });
        }
        setManualContent(nextContent);
        if (diffReview.chapterKey) {
            const key = String(diffReview.chapterKey);
            setManualContentByChapter((prev) => ({ ...(prev || {}), [key]: nextContent }));
        }
        dispatch({ type: 'SET_WORD_COUNT', payload: countChars(nextContent) });
        dispatch({ type: 'SET_SELECTION_COUNT', payload: 0 });
        clearDiffReview();
    };

    const saveDraftContent = async () => {
        if (!chapterInfo.chapter) return { success: false };
        const trimmedTitle = String(chapterInfo.chapter_title || '').trim();
        const payload = { content: manualContent };
        if (trimmedTitle) {
            payload.title = trimmedTitle;
        }
        const resp = await draftsAPI.updateContent(projectId, chapterInfo.chapter, payload);
        if (resp.data?.success) {
            const normalizedChapter = resp.data?.chapter || chapterInfo.chapter;
            if (normalizedChapter && normalizedChapter !== chapterInfo.chapter) {
                setChapterInfo((prev) => ({ ...prev, chapter: normalizedChapter }));
                dispatch({ type: 'SET_ACTIVE_DOCUMENT', payload: { type: 'chapter', id: normalizedChapter } });
                await loadChapters();
            }
            if (typeof resp.data?.title === 'string' && resp.data.title.trim()) {
                setChapterInfo((prev) => ({ ...prev, chapter_title: resp.data.title }));
            }
            dispatch({ type: 'SET_SAVED' });
            mutateChapter(manualContent, false);
        }
        return resp.data;
    };

    const handleManualSave = async () => {
        if (!chapterInfo.chapter) return;
        setIsSaving(true);
        try {
            const result = await saveDraftContent();
            if (result?.success) {
                addMessage('system', '\u8349\u7a3f\u5df2\u4fdd\u5b58');
            }
        } catch (e) {
            addMessage('error', '\u4fdd\u5b58\u5931\u8d25: ' + e.message);
        } finally {
            setIsSaving(false);
        }
    };

    const handleAnalyzeAndSave = async () => {
        if (!chapterInfo.chapter) return;
        setAnalysisLoading(true);
        try {
            const saved = await saveDraftContent();
            if (!saved?.success) {
                throw new Error(saved?.message || '\u4fdd\u5b58\u5931\u8d25');
            }
            const normalizedChapter = saved?.chapter || chapterInfo.chapter;
            const resp = await sessionAPI.analyze(projectId, {
                chapter: normalizedChapter,
                content: manualContent,
                chapter_title: chapterInfo.chapter_title || '',
            });
            if (resp.data?.success) {
                setAnalysisItems([{ chapter: normalizedChapter, analysis: resp.data.analysis || {} }]);
                setAnalysisDialogOpen(true);
                addMessage('system', '\u5206\u6790\u5b8c\u6210ï¼Œ\u8bf7\u786e\u8ba4\u5e76\u4fdd\u5b58\u3002');
            } else {
                throw new Error(resp.data?.error || '\u5206\u6790\u5931\u8d25');
            }
        } catch (e) {
            addMessage('error', '\u5206\u6790\u5931\u8d25: ' + e.message);
        } finally {
            setAnalysisLoading(false);
        }
    };

    const handleSaveAnalysis = async (payload) => {
        setAnalysisSaving(true);
        try {
            if (Array.isArray(payload)) {
                const resp = await sessionAPI.saveAnalysisBatch(projectId, {
                    items: payload,
                    overwrite: true,
                });
                if (!resp.data?.success) {
                    throw new Error(resp.data?.error || '\u5206\u6790\u5931\u8d25');
                }
            } else if (chapterInfo.chapter) {
                const resp = await sessionAPI.saveAnalysis(projectId, {
                    chapter: chapterInfo.chapter,
                    analysis: payload,
                    overwrite: true,
                });
                if (!resp.data?.success) {
                    throw new Error(resp.data?.error || '\u5206\u6790\u5931\u8d25');
                }
            }
            addMessage('system', '\u5206\u6790\u4fdd\u5b58\u5b8c\u6210');
            setAnalysisDialogOpen(false);
            setAnalysisItems([]);
        } catch (e) {
            addMessage('error', '\u4fdd\u5b58\u5931\u8d25: ' + e.message);
        } finally {
            setAnalysisSaving(false);
        }
    };

    // Phase 4.3: Handle user answer for AskUser
    // Card Handlers
    const handleCardSave = async () => {
        if (!activeCard) return;
        setIsSaving(true);
        try {
            const name = (cardForm.name || '').trim();
            if (!name) {
                throw new Error('å¡ç‰‡åç§°ä¸èƒ½ä¸ºç©º');
            }
            const stars = normalizeStars(cardForm.stars);
            const aliases = parseListInput(cardForm.aliases);
            if (activeCard.type === 'character') {
                const payload = {
                    name,
                    description: cardForm.description || '',
                    aliases,
                    stars
                };
                if (activeCard.isNew || !activeCard.originalName) {
                    await cardsAPI.createCharacter(projectId, payload);
                } else if (activeCard.originalName !== name) {
                    await cardsAPI.createCharacter(projectId, payload);
                    await cardsAPI.deleteCharacter(projectId, activeCard.originalName);
                } else {
                    await cardsAPI.updateCharacter(projectId, activeCard.originalName, payload);
                }
            } else {
                const rules = parseListInput(cardForm.rules);
                const immutableValue =
                    cardForm.immutable === 'true' ? true : cardForm.immutable === 'false' ? false : undefined;
                const payload = {
                    name,
                    description: cardForm.description || '',
                    aliases,
                    category: (cardForm.category || '').trim(),
                    rules,
                    stars
                };
                if (immutableValue !== undefined) {
                    payload.immutable = immutableValue;
                }
                if (activeCard.isNew || !activeCard.originalName) {
                    await cardsAPI.createWorld(projectId, payload);
                } else if (activeCard.originalName !== name) {
                    await cardsAPI.createWorld(projectId, payload);
                    await cardsAPI.deleteWorld(projectId, activeCard.originalName);
                } else {
                    await cardsAPI.updateWorld(projectId, activeCard.originalName, payload);
                }
            }
            try {
                const refreshed = activeCard.type === 'character'
                    ? await cardsAPI.getCharacter(projectId, name)
                    : await cardsAPI.getWorld(projectId, name);
                const refreshedData = refreshed?.data;
                if (refreshedData?.name) {
                    setActiveCard({
                        ...refreshedData,
                        type: activeCard.type,
                        isNew: false,
                        originalName: refreshedData.name,
                    });
                    setCardForm({
                        name: refreshedData.name || '',
                        description: refreshedData.description || '',
                        aliases: formatListInput(refreshedData.aliases),
                        stars: normalizeStars(refreshedData.stars),
                        category: refreshedData.category || '',
                        rules: formatRulesInput(refreshedData.rules),
                        immutable: refreshedData.immutable === true ? 'true' : refreshedData.immutable === false ? 'false' : 'unset'
                    });
                }
            } catch (error) {
                logger.error('Failed to refresh card data', error);
            }
            addMessage('system', 'å¡ç‰‡å·²æ›´æ–°');
            dispatch({ type: 'SET_SAVED' });
        } catch (e) {
            const detail = e?.response?.data?.detail || e?.response?.data?.error;
            addMessage('error', 'å¡ç‰‡ä¿å­˜å¤±è´¥: ' + (detail || e.message));
        } finally {
            setIsSaving(false);
        }
    };

    const renderMainContent = () => {
        if (state.activeActivity === 'fanfiction') {
            return (
                <FanfictionView
                    embedded
                    onClose={() => dispatch({ type: 'SET_ACTIVE_PANEL', payload: 'explorer' })}
                />
            );
        }
        return (
            <AnimatePresence mode="wait">
                {status === 'card_editing' && activeCard ? (
                    <motion.div
                        key="card-editor"
                        initial={{ opacity: 0, scale: 0.98, y: 10 }}
                        animate={{ opacity: 1, scale: 1, y: 0 }}
                        exit={{ opacity: 0, scale: 0.98, y: -10 }}
                        transition={{ duration: 0.3, ease: "easeOut" }}
                        className="h-full flex flex-col max-w-3xl mx-auto w-full pt-4"
                    >
                        <div className="flex items-center justify-between mb-6 pb-4 border-b border-border">
                            <div className="flex items-center gap-3">
                                <div className="p-2 bg-primary/10 rounded-lg text-primary">
                                    {activeCard.type === 'character' ? <div className="i-lucide-user" /> : <div className="i-lucide-globe" />}
                                    {activeCard.type === 'character' ? 'ğŸ‘¤' : 'ğŸŒ'}
                                </div>
                                <div>
                                    <p className="text-xs text-ink-400 font-mono uppercase tracking-wider">{activeCard.type === 'character' ? 'è§’è‰²å¡ç‰‡' : 'ä¸–ç•Œå¡ç‰‡'}</p>
                                </div>
                            </div>
                            <button
                                onClick={() => {
                                    setStatus('idle');
                                    setActiveCard(null);
                                }}
                                className="p-2 hover:bg-ink-100 rounded-lg transition-colors text-ink-400 hover:text-ink-700"
                                title="å…³é—­å¡ç‰‡ç¼–è¾‘"
                            >
                                <X size={20} />
                            </button>
                        </div>

                        <div className="space-y-6 flex-1 overflow-y-auto px-1 pb-20">
                            {/* Common: Name */}
                            <div className="space-y-1">
                                <label className="text-xs font-bold text-ink-500 tracking-wider">åç§°</label>
                                <Input
                                    value={cardForm.name}
                                    onChange={e => setCardForm(prev => ({ ...prev, name: e.target.value }))}
                                    className="font-serif text-lg bg-[var(--vscode-input-bg)] font-bold"
                                />
                            </div>

                            <div className="space-y-1">
                                <label className="text-xs font-bold text-ink-500 tracking-wider">æ˜Ÿçº§</label>
                                <select
                                    value={cardForm.stars}
                                    onChange={e => setCardForm(prev => ({ ...prev, stars: normalizeStars(e.target.value) }))}
                                    className="w-full h-10 px-3 rounded-[6px] border border-[var(--vscode-input-border)] bg-[var(--vscode-input-bg)] text-sm focus:ring-1 focus:ring-[var(--vscode-focus-border)]"
                                >
                                    <option value={3}>ä¸‰æ˜Ÿï¼ˆå¿…é¡»å…³æ³¨ï¼‰</option>
                                    <option value={2}>äºŒæ˜Ÿï¼ˆé‡è¦ï¼‰</option>
                                    <option value={1}>ä¸€æ˜Ÿï¼ˆå¯é€‰ï¼‰</option>
                                </select>
                            </div>

                            <div className="space-y-1">
                                <label className="text-xs font-bold text-ink-500 tracking-wider">åˆ«å</label>
                                <Input
                                    value={cardForm.aliases || ''}
                                    onChange={e => setCardForm(prev => ({ ...prev, aliases: e.target.value }))}
                                    placeholder="å¤šä¸ªåˆ«åç”¨é€—å·åˆ†éš”"
                                    className="bg-[var(--vscode-input-bg)]"
                                />
                            </div>

                            {activeCard.type === 'world' && (
                                <>
